---
layout: post
title: WCF.doc
date: 2018-03-20 09:58
author: tmasabari
comments: true
categories: [Services, WCF]
---
Windows Communication Foundation (WCF) is a secure, reliable, and scalable messaging platform for the .NET Framework 3.0.

With WCF, SOAP messages can be transmitted over a variety of supported protocols including IPC (named pipes), TCP, HTTP and MSMQ.

<strong>NetTcpBinding </strong>is the right choice for binary TCP communications that cross machine boundaries, <strong>BasicHttpBinding </strong>is the right choice for HTTP communications that must support legacy Web service protocols, and <strong>WSHttpBinding </strong>or<strong>WSFederationHttpBinding </strong>are the right choice for Web services that can leverage a richer set of standards including those for secure communications (the latter is used for federated security scenarios).

<strong>Security</strong>

<u><a href="http://www.codemag.com/article/0611051" target="_blank" rel="noopener">http://www.codemag.com/article/0611051</a></u>  <u><a href="http://www.codeproject.com/Articles/36732/WCF-FAQ-Part-security-related-FAQ" target="_blank" rel="noopener">http://www.codeproject.com/Articles/36732/WCF-FAQ-Part-security-related-FAQ</a></u>

<strong>Security concepts</strong>

<strong>Confidentiality</strong>: This feature ensures that information <u>does not go in to the wrong hands when it travels</u> from the sender to the receiver. Sensitive messages or specific <strong>message parts</strong> should be <strong>encrypted </strong>to ensure they cannot be openly viewed on the wire.

<strong>Integrity</strong>: This feature <u>ensures</u> that the receiver of the message <u>gets the same information </u>that the sender sent without any data tampering. Messages should be <strong>digitally signed</strong> to ensure they have not been altered between sender and receiver.

<strong>Authentication</strong>: identifying the message sender This feature verifies who the sender is and who the receiver is. Mutual authentication involves authenticating both the sender and the message receiver, to prevent possible man-in-the-middle attacks.

<strong>Authorization</strong>: This feature verifies whether the user is authorized to perform the action they are requesting from the application. After authenticating the message sender, authorization determines what system features and functionality they are entitled to execute.

A variety of mutual authentication mechanisms are supported using token formats such as Windows tokens, username and password, certificates and issued tokens (in a federated environment).

Authorization can be based on Windows roles, ASP.NET roles or you can provide custom authorization policies. Message protection (integrity and confidentiality) can be based on symmetric session keys, or asymmetric keys for single-hop protection.

<strong>Two aspects of WCF security</strong>

message level = The first is the data and = it is independent of the protocol = encrypting data

at the channel level = the second is the medium on which the data travels, i.e., the protocol.  =at the transport level (i.e., protocol level)

<img class="wp-image-1114" src="/wp-content/uploads/2018/03/image2-1.png" alt="image2 1" /><img class="wp-image-1109" src="/wp-content/uploads/2018/03/image1.jpg" alt="image1" />
<table>
<tbody>
<tr>
<td><strong> </strong></td>
<td><strong>Transport</strong></td>
<td><strong>Message</strong></td>
</tr>
<tr>
<td>Scenarios when we should be using one of them</td>
<td>When there are no intermediate systems in between, this is the best methodology.

If it’s an intranet type of solution, this is the most recommended methodology.</td>
<td>When there are intermediate systems like one more WCF service through which message is routed, then message security is the way to go.</td>
</tr>
<tr>
<td><strong>Advantages</strong></td>
<td>Does not need any extra coding as protocol inherent security is used.

Performance is better as we can use hardware accelerators to enhance performance.

There is a lot of interoperability support and communicating clients do not need to understand WS security as it’s built in the protocol itself.</td>
<td>Provides end to end security as it’s not dependent on the protocol. Any intermediate hop in the network does not affect the application.

Supports a wide set of security options as it is not dependent on the protocol. We can also implement custom security.</td>
</tr>
<tr>
<td><strong>Disadvantages</strong></td>
<td>As it’s a protocol implemented security, it works only point to point.

As security is dependent on protocol, it has limited security support and is bound to the protocol security limitations.</td>
<td>Needs application refactoring to implement security.

As every message is encrypted and signed, there are performance issues.

Does not support interoperability with old ASMX webservices.</td>
</tr>
</tbody>
</table>
WCF uses transport protocols like TCP, HTTP, MSMQ, etc., and each of these protocols have their own security mechanisms.
<table>
<tbody>
<tr>
<td><strong>Binding</strong></td>
<td><strong>Transport Mode?</strong></td>
<td><strong>Message Mode?</strong></td>
<td><strong>Mixed Mode?</strong></td>
<td><strong>Client Credential Type</strong></td>
</tr>
<tr>
<td>BasicHttpBinding</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>None

Windows – default authentication

Basic

Certificate</td>
</tr>
<tr>
<td>WsHttpBinding</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>None

<strong>Transport</strong>

<strong>Message</strong>

<strong>Transport with message </strong>credentials</td>
</tr>
<tr>
<td>WsDualHttpBinding</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>NetTcpBinding</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>NetNamedPipeBinding</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>NetMsmqBinding</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>MsmqIntegrationBinding</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong>Criteria</strong></td>
<td><strong>BasicHttpBinding</strong></td>
<td><strong>WsHttpBinding</strong></td>
</tr>
<tr>
<td>Security support</td>
<td>This supports the old ASMX style, i.e., WS-BasicProfile 1.1.</td>
<td>This exposes web services using WS-* specifications.</td>
</tr>
<tr>
<td>Compatibility</td>
<td>This is aimed for clients who do not have .NET 3.0 installed and it supports wider ranges of clients. Many clients like Windows 2000 still do not run .NET 3.0. So an older version of .NET can consume this service.</td>
<td>As it is built using WS-* specifications, it does not support wider ranges of clients and it cannot be consumed by older .NET versions less than version 3.</td>
</tr>
<tr>
<td>SOAP version</td>
<td>SOAP 1.1</td>
<td>SOAP 1.2 and WS-Addressing specification.</td>
</tr>
<tr>
<td>Reliable messaging</td>
<td>Not supported. In other words, if a client fires two or three calls, you really do not know they will return back in the same order.</td>
<td>Supported as it supports WS-* specifications.</td>
</tr>
<tr>
<td>Default security options</td>
<td><u>By default</u>, there is no security provided for messages when the client calls happen. In other words, <u>data is sent as plain text</u>.</td>
<td>As WsHttBinding supports WS-*, it has WS-Security enabled by default. So the data is not sent as plain text.</td>
</tr>
</tbody>
</table>
&lt;bindings&gt;&lt;netTcpBinding&gt;

&lt;binding name="netTcp"&gt;

&lt;security mode="Transport/Message"&gt;

&lt;transport/message clientCredentialType="None" /&gt;

&lt;/security&gt;

&lt;/binding&gt;

&lt;/netTcpBinding&gt;&lt;/bindings&gt;

<strong>five possible security modes:</strong>

<strong>None</strong>. Turns security off.

<strong>Transport</strong>. Uses transport security for mutual authentication and message protection.

<strong>Message</strong>. Uses message security for mutual authentication and message protection.

<strong>Both</strong>. Allows you to supply settings for transport and message-level security (only MSMQ supports this).

<strong>TransportWithMessageCredential</strong>. Credentials are passed with the message and message protection and server authentication are provided by the transport layer.

<strong>TransportCredentialOnly. </strong>Client credentials are passed with the transport layer and no message protection is applied.

Message security supports any of the following settings for <em>clientCredentialType</em>:

None

Windows

UserName

Certificate

IssuedToken

<u><a href="http://www.codeproject.com/Articles/18645/WCF-Transport-Layer-Security-using-wsHttpBinding-a" target="_blank" rel="noopener">http://www.codeproject.com/Articles/18645/WCF-Transport-Layer-Security-using-wsHttpBinding-a</a></u>

WCF webservice using transport layer security and SSL configured on IIS6.0

So first configure the website on SSL. To get an idea on how to configure SSL, you can go through <a href="http://msdn2.microsoft.com/en-us/library/aa302411.aspx" target="_blank" rel="noopener">this</a>. Make sure that when you configure the SSL, the certificate CN value should be exactly the same as the URL of the website. For example, if your webservice address is http:\www.example.com, then issue a certificate on the name : CN = http:\www.example.com.

&lt;wsHttpBinding&gt;

&lt;binding name="TransportSecurity"&gt;

&lt;security mode="Transport"&gt;

&lt;transport clientCredentialType="None"/&gt;

&lt;/security&gt;

&lt;/binding&gt;

&lt;/wsHttpBinding&gt;

tie up the bindings with the end points. So use the bindingConfiguration tag to specify the binding name. Change mexHttpBinding to mexHttpsBinding in the second end point

&lt;service name="WCFWSHttps.Service1" behaviorConfiguration="WCFWSHttps.Service1Behavior"&gt;

<em>&lt;!-- Service Endpoints </em>--&gt;

&lt;endpoint address="https://localhost/WCFWSHttps/Service1.svc"

binding="wsHttpBinding" bindingConfiguration="TransportSecurity"

contract="WCFWSHttps.IService1"/&gt;

&lt;endpoint address="mex" binding="mexHttpsBinding" contract="IMetadataExchange"/&gt;

&lt;/service&gt;

&lt;serviceBehaviors&gt;

&lt;behavior name="returnFaults"&gt;

&lt;serviceDebug includeExceptionDetailInFaults="true"/&gt;

&lt;serviceMetadata httpsGetEnabled="true"/&gt;

&lt;serviceTimeouts/&gt;

&lt;/behavior&gt;

&lt;/serviceBehaviors&gt;

Install certificate to IIS -&gt; Servername (root) -&gt; “server certificates”

Add bindings to web site -&gt; “Default Web sit” -&gt; Bindings.

Host WCF project as <u><a href="http://stackoverflow.com/questions/720807/wcf-service-attribute-value-in-the-servicehost-directive-could-not-be-found" target="_blank" rel="noopener">application </a></u>(virtual directory will not work throws error)

Create certificate Run as administrator (required only if iis express certificates is not available) <u><a href="https://www.digicert.com/ssl-certificate-installation-microsoft-iis-7.htm" target="_blank" rel="noopener">https://www.digicert.com/ssl-certificate-installation-microsoft-iis-7.htm</a></u>

Hostname DESKTOP-FLHDRQ7

makecert -r -pe -n "CN= DESKTOP-FLHDRQ7" -b 01/01/2000          -e 01/01/2050 -eku 1.3.6.1.5.5.7.3.1 -ss my -sr localMachine -sky exchange         -sp "Microsoft RSA SChannel Cryptographic Provider" -sy 12

<u><a href="http://stackoverflow.com/questions/2792539/is-it-possible-to-force-the-wcf-test-client-to-accept-a-self-signed-certificate" target="_blank" rel="noopener">http://stackoverflow.com/questions/2792539/is-it-possible-to-force-the-wcf-test-client-to-accept-a-self-signed-certificate</a></u> <u><a href="http://www.codewrecks.com/blog/index.php/2011/11/21/how-to-test-ssl-based-wcf-services/" target="_blank" rel="noopener">http://www.codewrecks.com/blog/index.php/2011/11/21/how-to-test-ssl-based-wcf-services/</a></u>

<img class="wp-image-1111" src="/wp-content/uploads/2018/03/image3-1.png" alt="image3 1" />

Suppress certificate error

using System.Net;

using System.Net.Security;

using System.Security.Cryptography.X509Certificates;

static void Main(string[] args)

{

ServicePointManager.ServerCertificateValidationCallback =

new RemoteCertificateValidationCallback(IgnoreCertificateErrorHandler);

IService1 client = new Service1Client();

System.Console.WriteLine(client.GetData(10));

Console.ReadKey();

}

public static bool IgnoreCertificateErrorHandler(object sender,

X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)

{

return true;

}

Diagnostics

&lt;diagnostics&gt;

&lt;messageLogging logEntireMessage="true"

maxMessagesToLog="300" logMessagesAtServiceLevel="true"

logMalformedMessages="true" logMessagesAtTransportLevel="true"/&gt;

&lt;/diagnostics&gt;

<strong>Enable Transactions in Services</strong>

<strong>Rest</strong>

<u><a href="http://stackoverflow.com/questions/11299273/transactions-with-asp-net-web-api" target="_blank" rel="noopener">http://stackoverflow.com/questions/11299273/transactions-with-asp-net-web-api</a></u>

I believe you are referring to distributed transactions (via MSDTC) which can propagate over service boundaries.

However, <strong>distributed transactions over WCF RESTful services are not possible b</strong>ecause there is simply no way to propagate and manage the transaction state over plain HTTP requests.

You may want to look into plain WCF services, over HTTP (wsHttpBinding) or TCP/IP (net.tcp), or even give a look on <a href="http://msdn.microsoft.com/en-us/library/cc668792.aspx" target="_blank" rel="noopener">WCF Data Services</a>.

The <a href="http://msdn.microsoft.com/en-us/library/system.transactions.transactioninterop(v=vs.100).aspx" target="_blank" rel="noopener">TransactionInterop</a> class exists to provide support for working with transactions between process boundaries, leveraging MS DTC. The major caveat to this is that MS DTC will need to be enabled and configured at client and server. This is only really achievable if your services are being invoked within a Windows Active Directory Domain.
<h1><strong>WCF</strong></h1>
<u><a href="https://msdn.microsoft.com/en-us/library/ff384250.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/ff384250.aspx</a></u>

To add transaction support to a WCF service, you will take the following actions:

Add transaction support to the service contract. This is required.

Add transaction support to the code that implements the service contract. This is required.

Configure transactions in the implementation code. This is optional.

Enable transactions on the binding. This is required.

The TransactionFlow attribute specifies whether the operation supports transactions. There are three possible values for this attribute:

NotAllowed : The operation cannot participate in a transaction. This is the default value for this attribute.- Use it for database/io read operations

Allowed : The operation will participate in a transaction if the client creates one.

Mandatory : In order to call this operation, the client must create a transaction.

<u><a href="http://www.codeproject.com/Articles/38793/Steps-to-Enable-Transactions-in-WCF" target="_blank" rel="noopener">http://www.codeproject.com/Articles/38793/Steps-to-Enable-Transactions-in-WCF</a></u>

1. Attribute Interface Methods with TransactionFlow

[ServiceContract]

public interface IService1

{

[OperationContract]

[TransactionFlow(TransactionFlowOption.Allowed)]

void UpdateData();

}

Attribute the Implementation with TransactionScopeRequired, , TransactionAutoComplete

Setting the TransactionScopeRequired property to true specifies that<strong> clients cannot call these methods unless they are part of a transaction.</strong> Setting the TransactionAutoComplete property to true specifies that the <strong>transaction will complete automatically if no exceptions occur.</strong> This is the default value for this property.

[OperationBehavior(TransactionScopeRequired = true, TransactionAutoComplete=false)]

public void UpdateData()

{

<em>//if error occurs it will abort the transaction back at the client.  If no error then the transaction will be passed back in an active state.</em>

SqlConnection objConnection = new SqlConnection(strConnection);

objConnection.Open();

SqlCommand objCommand = new SqlCommand("insert into Customer

(CustomerName,CustomerCode) values('sss','sss')",objConnection);

objCommand.ExecuteNonQuery();

objConnection.Close();

}

Binding

you must use a binding that supports transactions. All of the WCF supplied bindings support transactions, with the exception of the BasicHttpBinding and NetPeerTcpBinding bindings.

&lt;bindings&gt;&lt;wsHttpBinding&gt;&lt;binding name="TransactionalBind" transactionFlow="true"/&gt;&lt;/wsHttpBinding&gt;&lt;/bindings&gt;

Call the 2 Services in One Transaction from client

using (TransactionScope ts = new TransactionScope(TransactionScopeOption.RequiresNew))

{

try

{

<em>// Call your webservice transactions here</em>

<em>…...</em>

<em>//All is good if reached here so can complete the transaction.  Otherwise this will never be executed and when the end using for the transaction is hit, rollbacks will occur.</em>

ts.Complete();

}

catch (Exception ex)

{

ts.Dispose();

}

}

This works in a scenario of a .net thick client calling a WCF service hosted by IIS, which in turn uses SQL server for the backend. You must have MSDTC turned on on the IIS and SQL servers (and the client).

<strong>Instance management</strong>

Instance <u><a href="http://www.codeproject.com/Articles/86007/ways-to-do-WCF-instance-management-Per-call-Per" target="_blank" rel="noopener">http://www.codeproject.com/Articles/86007/ways-to-do-WCF-instance-management-Per-call-Per</a></u>

WCF client makes a request to a WCF service object.

WCF service object is instantiated.

WCF service instance serves the request and sends the response to the WCF client.

Following is a pictorial representation of how WCF requests and responses work.

<img class="wp-image-1110" src="/wp-content/uploads/2018/03/image4.jpg" alt="image4" />

Following are different ways by which you can create WCF instances:

Create a new WCF service instance on every WCF client method call.

Only one WCF service instance should be created for every WCF client session.

Only one global WCF service instance should be created for all WCF clients.

To meet the above scenarios, WCF has provided three ways by which you can control WCF service instances:

Per call

Per session

Single instance

[ServiceBehavior(InstanceContextMode = InstanceContextMode.Percall)]

public class Service : IService

<img class="wp-image-1112" src="/wp-content/uploads/2018/03/image5.jpg" alt="image5" />

[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]

<img class="wp-image-1115" src="/wp-content/uploads/2018/03/image6.jpg" alt="image6" />

[ServiceBehavior(InstanceContextMode = InstanceContextMode.Single)]

<img class="wp-image-1108" src="/wp-content/uploads/2018/03/image7.jpg" alt="image7" />
<h3>Per call</h3>
You want a stateless services.

Your service holds intensive resources like connection objects and huge memory objects.

Scalability is a prime requirement. You would like to have a scaled out architecture.

Your WCF functions are called in a single threaded model.
<h3>Per session</h3>
You want to maintain states between WCF calls.

You a scaled up architecture.

Light resource references.
<h3>Single</h3>
You want share global data through your WCF service.

Scalability is not a concern.

<strong>Concurrency management </strong>

<u><a href="http://www.codeproject.com/Articles/89858/WCF-Concurrency-Single-Multiple-and-Reentrant-and" target="_blank" rel="noopener">http://www.codeproject.com/Articles/89858/WCF-Concurrency-Single-Multiple-and-Reentrant-and</a></u>

WCF concurrency helps us configure how WCF service instances can serve multiple requests at the same time. You will need WCF concurrency for the below prime reasons; there can be other reasons as well but these stand out as important reasons:

<strong>Increase throughput</strong>: Many times you want to increase the amount of work your WCF service instance does at any moment of time. In other words, you would like to increase the throughput. Throughput means how much work a given thing can do.

By default, a WCF service handles only one request at a given moment of time.

<strong>Integration with a legacy system</strong>: Many times your WCF services interact with legacy systems like VB6, COM, etc. It’s very much possible that these systems are not multithreaded, in other words they handle only one request at any given time. So even though your WCF service has concurrent capabilities, you would still like to handle one request at a time. This is achieved by using throttling in combination with WCF concurrency capabilities.

<img class="wp-image-1116" src="/wp-content/uploads/2018/03/image8.jpg" alt="image8" />

<img class="wp-image-1107" src="/wp-content/uploads/2018/03/image10.jpg" alt="image10" />

<strong>Single</strong>: A s<u>ingle request has access to the WCF service object </u>at a given moment of time. So only one request will be processed at any given moment of time. The other requests have to wait until the request processed by the WCF service is completed.

<strong>Multiple</strong>: In this scenario, multiple requests can be handled by the WCF service object at any given moment of time. In other words, <strong>requests are processed at the same time by spawning multiple threads on the WCF server object.</strong> So you have great throughput here but you need to ensure concurrency issues related to WCF server objects.

<strong>Reentrant</strong>: A single request thread has access to the WCF service object, but the thread can exit the WCF service to call another WCF service or can also call a WCF client through callback and reenter without deadlock.

<img class="wp-image-1113" src="/wp-content/uploads/2018/03/image9.jpg" alt="image9" />
<table>
<tbody>
<tr>
<td><strong>InstanceContext
Mode</strong></td>
<td><strong>ConcurrencyMode</strong></td>
</tr>
<tr>
<td><strong>Single (Default)</strong></td>
<td><strong>Multiple</strong></td>
<td><strong>Reentrant</strong></td>
</tr>
<tr>
<td>Single
(Single instance for all clients)</td>
<td>Single thread for all clients.</td>
<td>Multiple threads for all clients.</td>
<td>Single threads for all clients, locks are released when calls diverted to other WCF services.</td>
</tr>
<tr>
<td>PerSession (Default)聽
(Multiple instance per client)</td>
<td>Single thread for every client.</td>
<td>Multiple threads for every request.</td>
</tr>
<tr>
<td>PerCall (Multiple instances for every method call)</td>
<td>Single thread for every client.</td>
<td>Single thread for every client</td>
</tr>
</tbody>
</table>
<h2><strong>Throttling behavior</strong></h2>
MaxConcurrentCalls: Limits the number of concurrent requests that can be processed by WCF service instances.

MaxConcurrentInstances: Limits the number of service instances that can be allocated at a given time. When it’s PerCall services, this value matches the number of concurrent calls. For PerSession services, this value equals the number of active session instances. This setting doesn’t matter for Single instancing mode, because only one instance is ever created.

MaxConcurrentSessions: Limits the number of active sessions allowed for the service.
<h2><strong>Default values for WCF throttling</strong></h2>
Below is a simple table which shows the default settings for throttling for different WCF versions:
<table>
<tbody>
<tr>
<td></td>
<td><strong>MaxConcurrentSessions</strong></td>
<td><strong>MaxConcurrentCalls </strong></td>
<td><strong>MaxConcurrentInstances </strong></td>
</tr>
<tr>
<td>WCF 3.0 / 3.5</td>
<td>6</td>
<td>26</td>
<td>10</td>
</tr>
<tr>
<td>WCF 4.0</td>
<td>16 * processorcount MaxConcurrentCalls</td>
<td>MaxConcurrentCalls
+
MaxConcurrentSessions 100 * processorcount</td>
<td>100 * processorcount</td>
</tr>
</tbody>
</table>
