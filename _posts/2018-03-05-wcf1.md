---
layout: post
title: WCF
date: 2018-03-05 21:03
author: tmasabari
comments: true
categories: [DataTransaction, Interview Preparation, Services, Transactions, WCF]
---
<h2>Background</h2>
<ul>
 	<li>Windows Communication Foundation (WCF) is a secure, reliable, and scalable messaging platform for the <strong>.NET Framework 3.0.</strong></li>
 	<li>With WCF, SOAP messages can be transmitted over a variety of supported protocols including <strong>IPC (named pipes), TCP, HTTP and MSMQ</strong>.</li>
 	<li>Most of the WCF functionality is included in a single assembly called System.ServiceModel.dll, located in the System.ServiceModel namespace.</li>
</ul>
<strong><b>What are the ABCs of WCF?</b></strong>

&nbsp;

https://www.infoq.com/articles/ws-standards-wcf-bustamante

https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/web-services-protocols-supported-by-system-provided-interoperability-bindings

ABC stands for address, binding, and contract, they are also called WCF endpoint.
<ul>
 	<li><strong><b> A - stands for Address: Where is the service?</b></strong></li>
 	<li><strong><b> B - stands for Binding: How do I talk to the service?</b></strong></li>
 	<li><strong><b> C - stands for Contract: What can the service do for me?</b></strong></li>
</ul>
&nbsp;
<h2>WCF Terms</h2>
<strong>Revisiting SOAP+WSDL</strong>
<ul>
 	<li>SOAP was first introduced in 1999 - a short specification that describes</li>
 	<li>how to format messages between applications,</li>
 	<li>leveraging XML at its core to promote interoperability.</li>
 	<li>the SOAP protocol really only describes a wrapper around a message:
<ol>
 	<li>where to place headers,</li>
 	<li>where to place the message payload,</li>
 	<li>how to indicate the intention of the request (or, the "action") -</li>
 	<li>the basic requirements that enable platforms to process SOAP messages to perform work.</li>
</ol>
</li>
 	<li>WSDL describes the application-specific messaging requirements- the Url where a service can be reached, the supported operations (actions) at that location, and the format for messages and related type definitions described by XSD Schema.</li>
</ul>
&nbsp;
<dl>
 	<dt>What is message</dt>
 	<dd>A <strong>self-contained unit of data</strong> that can consist of several parts, including a <strong>body and headers.</strong></dd>
 	<dd>A message is nothing but a packet and WCF uses this packet to transfer the information from source to destination. This message is contained in the header or body.</dd>
 	<dd><img src="http://csharpcorner.mindcrackerinc.netdna-cdn.com/UploadFile/788083/how-to-implement-message-contract-in-wcf/Images/MessageWCF1.jpg" alt="MessageWCF1.jpg" /></dd>
</dl>
<strong>Message Contract</strong>
<ul>
 	<li>A message contract is used to control the structure of a message body and serialization process.</li>
 	<li>It is used to send/access the information in the soap header.</li>
 	<li>By use of a Message Contract we can customize the parameters sent using a SOAP message between the client and the server.</li>
 	<li>Data contracts are used to define the data structure and generate the XML for the data you want to pass. (if complex data is passed this become compulsory). DataContract has limited control over the SOAP message and all that control is related to contents inside body of the SOAP message</li>
 	<li>If you want to go for more control on your SOAP Message then you should go for a Message Contract. Data contract will be specified as message body. <strong>Example authentication tokens or codes</strong></li>
 	<li><code>[MessageContract]
public class AuthorResponse
{
[MessageBodyMember]
public Auther Obj;
}
[DataContract]
public class Auther
{
[DataMember]
public string FirstName { get; set;}
}
</code></li>
</ul>
<dl>
 	<dt>What is service</dt>
 	<dd>A construct that <strong>exposes one or more endpoint</strong>s, with each <strong>endpoint exposing one or more service</strong> operations.</dd>
</dl>
<dl>
 	<dt>What is endpoint</dt>
 	<dd>A construct at which messages are sent or received (or both). It comprises a <strong>location (an address) that defines where messages can be sent, a specification of the communication mechanism (a binding) that described how messages should be sent,</strong> and a definition for a set of messages that can be sent or received (or both) at that location (a service contract) that describes what message can be sent. A WCF service is exposed to the world as a collection of endpoints.</dd>
</dl>
<dl>
 	<dt>What is application endpoint</dt>
 	<dd>An endpoint exposed by the application and that corresponds to a service contract implemented by the application.</dd>
</dl>
<dl>
 	<dt>infrastructure endpoint</dt>
 	<dd>An endpoint that is exposed by the infrastructure to facilitate functionality that is needed or provided by the service that does not relate to a service contract. For example, a service might have an infrastructure endpoint that provides metadata information.</dd>
</dl>
<dl>
 	<dt>What is address</dt>
 	<dd>Specifies the location where messages are received. It is specified as a Uniform Resource Identifier (URI).</dd>
 	<dd>The URI schema part names the <strong>transport mechanism</strong> to use to reach the address, such as HTTP and TCP. The <strong>hierarchical</strong> part of the URI contains a <strong>unique location</strong> whose format is dependent on the transport mechanism.</dd>
 	<dd>The endpoint address enables you to create unique endpoint addresses for each endpoint in a service or, under certain conditions, to share an address across endpoints. The following example shows an address using the HTTPS protocol with a non-default port:
<div>
<div>
<div>
<div>
<pre>HTTPS://cohowinery:8005/ServiceModelSamples/CalculatorService
</pre>
</div>
</div>
</div>
</div></dd>
</dl>
<dl>
 	<dt>What is binding</dt>
 	<dd>Defines how an endpoint communicates to the world. It is constructed of a set of components called binding elements that "stack" one on top of the other to create the communication infrastructure. At the very least, a binding defines the transport (such as HTTP or TCP) and the encoding being used (such as text or binary). A binding can contain binding elements that specify details like the security mechanisms used to secure messages, or the message pattern used by an endpoint. For more information, see <a href="http://msdn.microsoft.com/en-us/library/ms733830.aspx" rel="nofollow">Configuring Services</a>.</dd>
</dl>
<dl>
 	<dt>binding element</dt>
 	<dd>Represents a particular piece of the binding, such as a transport, an encoding, an implementation of an infrastructure-level protocol (such as WS-ReliableMessaging), or any other component of the communication stack.</dd>
</dl>
<dl>
 	<dt>What is behaviors</dt>
 	<dd>A component that controls various run-time aspects of a service, an endpoint, a particular operation, or a client. Behaviors are grouped according to scope: common behaviors affect all endpoints globally, service behaviors affect only service-related aspects, endpoint behaviors affect only endpoint-related properties, and operation-level behaviors affect particular operations. For example, one service behavior is throttling, which specifies how a service reacts when an excess of messages threaten to overwhelm its handling capabilities. An endpoint behavior, on the other hand, controls only aspects that are relevant to endpoints, such as how and where to find a security credential.</dd>
</dl>
<dl>
 	<dt>What is system-provided bindings</dt>
 	<dd>WCF includes a number of system-provided bindings. These are collections of binding elements that are optimized for specific scenarios. For example, the <a href="http://msdn.microsoft.com/en-us/library/system.servicemodel.wshttpbinding.aspx" rel="nofollow">WSHttpBinding</a> is designed for interoperability with services that implement various WS-* specifications. These predefined bindings save time by presenting only those options that can be correctly applied to the specific scenario. If a predefined binding does not meet your requirements, you can create your own custom binding.</dd>
</dl>
<dl>
 	<dt>What is configuration versus coding</dt>
 	<dd>Control of an application can be done either through coding, through configuration, or through a combination of both. Configuration has the advantage of allowing someone other than the developer (for example, a network administrator) to set client and service parameters after the code is written and without having to recompile. Configuration not only enables you to set values like endpoint addresses, but also allows further control by enabling you to add endpoints, bindings, and behaviors. Coding allows the developer to retain strict control over all components of the service or client, and any settings done through the configuration can be inspected and if needed overridden by the code.</dd>
</dl>
<dl>
 	<dt>What is service operation</dt>
 	<dd>A procedure defined in a service's code that implements the functionality for an operation. This operation is exposed to clients as methods on a WCF client. The method can return a value, and can take an optional number of arguments, or take no arguments, and return no response. For example, an operation that functions as a simple "Hello" can be used as a notification of a client's presence and to begin a series of operations.</dd>
</dl>
<dl>
 	<dt>service contract</dt>
 	<dd>Ties together multiple related operations into a single functional unit. The contract can define service-level settings, such as the namespace of the service, a corresponding callback contract, and other such settings. In most cases, the contract is defined by creating an interface in the programming language of your choice and applying the <a href="http://msdn.microsoft.com/en-us/library/system.servicemodel.servicecontractattribute.aspx" rel="nofollow">ServiceContractAttribute</a> attribute to the interface. The actual service code results by implementing the interface.</dd>
</dl>
<dl>
 	<dt>What is operation contract</dt>
 	<dd>An operation contract defines the parameters and return type of an operation. When creating an interface that defines the service contract, you signify an operation contract by applying the <a href="http://msdn.microsoft.com/en-us/library/system.servicemodel.operationcontractattribute.aspx" rel="nofollow">OperationContractAttribute</a> attribute to each method definition that is part of the contract. The operations can be modeled as taking a single message and returning a single message, or as taking a set of types and returning a type. In the latter case, the system will determine the format for the messages that need to be exchanged for that operation.</dd>
</dl>
<dl>
 	<dt>What is message contract</dt>
 	<dd>Describes the format of a message. For example, it declares whether message elements should go in headers versus the body, what level of security should be applied to what elements of the message, and so on.</dd>
</dl>
<dl>
 	<dt>What is fault contract</dt>
 	<dd>Can be associated with a service operation to denote errors that can be returned to the caller. An operation can have zero or more faults associated with it. These errors are SOAP faults that are modeled as exceptions in the programming model.</dd>
</dl>
<dl>
 	<dt>What is data contract</dt>
 	<dd>The descriptions in metadata of the data types that a service uses. This enables others to interoperate with the service. The data types can be used in any part of a message, for example, as parameters or return types. If the service is using only simple types, there is no need to explicitly use data contracts.</dd>
</dl>
<dl>
 	<dt>What is hosting</dt>
 	<dd>A service must be hosted in some process. A <strong><em>host</em> is an application that controls the lifetime of the service</strong>. Services can be<strong> self-hosted or managed</strong> by an existing hosting process.</dd>
</dl>
<dl>
 	<dt>What is self-hosted service</dt>
 	<dd>A service that runs within a process application that the developer created. The developer controls its <strong>lifetime</strong>, <strong>sets the properties</strong> of the service, opens the service (which sets it into a <strong>listening mode</strong>), and <strong>closes</strong> the service.</dd>
</dl>
<dl>
 	<dt>What is hosting process</dt>
 	<dd>An application that is designed to host services. These include Internet Information Services (IIS), Windows Activation Services (WAS), and Windows Services. In these hosted scenarios, the host controls the lifetime of the service. For example, using IIS you can set up a virtual directory that contains the service assembly and configuration file. When a message is received, IIS starts the service and controls its lifetime.</dd>
</dl>
<dl>
 	<dt>What is instancing</dt>
 	<dd>A service has an instancing model. There are three instancing models: "single," in which a single CLR object services all the clients; "per call," in which a new CLR object is created to handle each client call; and "per session," in which a set of CLR objects is created, one for each separate session. The choice of an instancing model depends on the application requirements and the expected usage pattern of the service.</dd>
</dl>
<dl>
 	<dt>What is client application</dt>
 	<dd>A program that exchanges messages with one or more endpoints. The client application begins by creating an instance of a WCF client and calling methods of the WCF client. It is important to note that a single application can be both a client and a service.</dd>
</dl>
<dl>
 	<dt>What is channel</dt>
 	<dd>A concrete implementation of a binding element. The binding represents the configuration, and the channel is the implementation associated with that configuration. Therefore, there is a channel associated with each binding element. Channels stack on top of each other to create the concrete implementation of the binding: the channel stack.</dd>
</dl>
<dl>
 	<dt>What is WCF client</dt>
 	<dd>A client-application construct that exposes the service operations as methods (in the .NET Framework programming language of your choice, such as Visual Basic or Visual C#). Any application can host a WCF client, including an application that hosts a service. Therefore, it is possible to create a service that includes WCF clients of other services. A WCF client can be automatically generated by using the <a href="http://msdn.microsoft.com/en-us/library/aa347733.aspx" rel="nofollow">ServiceModel Metadata Utility Tool (Svcutil.exe)</a> and pointing it at a running service that publishes metadata.</dd>
</dl>
<dl>
 	<dt>What is metadata</dt>
 	<dd>In a service, describes the characteristics of the service that an external entity needs to understand to communicate with the service. Metadata can be consumed by the <a href="http://msdn.microsoft.com/en-us/library/aa347733.aspx" rel="nofollow">ServiceModel Metadata Utility Tool (Svcutil.exe)</a> to generate a WCF client and accompanying configuration that a client application can use to interact with the service. The metadata exposed by the service includes XML schema documents, which define the data contract of the service, and WSDL documents, which describe the methods of the service. When enabled, metadata for the service is automatically generated by WCF by inspecting the service and its endpoints. To publish metadata from a service, you must explicitly enable the metadata behavior.</dd>
</dl>
<dl>
 	<dt>What is security</dt>
 	<dd>In WCF, includes confidentiality (encryption of messages to prevent eavesdropping), integrity (the means for detection of tampering with the message), authentication (the means for validation of servers and clients), and authorization (the control of access to resources). These functions are provided by either leveraging existing security mechanisms, such as TLS over HTTP (also known as HTTPS), or by implementing one or more of the various WS-* security specifications.</dd>
</dl>
<dl>
 	<dt>What is transport security mode</dt>
 	<dd>Specifies that confidentiality, integrity, and authentication are provided by the transport layer mechanisms (such as HTTPS). When using a transport like HTTPS, this mode has the advantage of being efficient in its performance, and well understood because of its prevalence on the Internet. The disadvantage is that this kind of security is applied separately on each hop in the communication path, making the communication susceptible to a "man in the middle" attack.</dd>
</dl>
<dl>
 	<dt>What is message security mode</dt>
 	<dd>Specifies that security is provided by implementing one or more of the security specifications, such as the specification named <a href="http://go.microsoft.com/fwlink/?LinkId=94684" target="_blank" rel="nofollow noopener">Web Services Security: SOAP Message Security</a>. Each message contains the necessary mechanisms to provide security during its transit, and to enable the receivers to detect tampering and to decrypt the messages. In this sense, the security is encapsulated within every message, providing end-to-end security across multiple hops. Because security information becomes part of the message, it is also possible to include multiple kinds of credentials with the message (these are referred to as <em>claims</em>). This approach also has the advantage of enabling the message to travel securely over any transport, including multiple transports between its origin and destination. The disadvantage of this approach is the complexity of the cryptographic mechanisms employed, resulting in performance implications.</dd>
</dl>
<dl>
 	<dt>What is transport with message credential security mode</dt>
 	<dd>Specifies the use of the transport layer to provide confidentiality, authentication, and integrity of the messages, while each of the messages can contain multiple credentials (claims) required by the receivers of the message.</dd>
</dl>
<dl>
 	<dt>What is WS-*</dt>
 	<dd>Shorthand for the growing set of <strong>Web Service (WS) specifications</strong>, such as WS-Security, WS-ReliableMessaging, and so on, that are implemented in WCF.</dd>
</dl>
<h3>WS-* standards</h3>
<h3>WS-I Profiles</h3>
<ul>
 	<li>Web Services Interoperability Organization - is an industry group to pro-mote interoperability across the stack of web services specifications.</li>
 	<li>It publishes web service profiles, sample applications, and test tools for help. One of the popular profiles it has published is the WS-I Basic Profile.</li>
 	<li>WS-I is governed by a Board of Directors, and Microsoft is one of the board members.</li>
</ul>
<h3>WS-Addressing</h3>
<ul>
 	<li>allows web services to communicate addressing infor-mation.</li>
 	<li>With traditional web services, addressing information is carried by the transport layer, and the web service message itself knows nothing about its destination.</li>
 	<li>With this new standard, <strong>addressing in-formation will be included in the XML message</strong> itself. A <strong>SOAP header</strong> can be added to the message for this purpose. The network-level <strong>transport</strong> is now responsible only for <strong>delivering</strong> that message to a <strong>dispatcher</strong> capable of reading the metadata.</li>
</ul>
<h3>WS-Security</h3>
<ul>
 	<li>handle security issues within SOAP messages.</li>
 	<li>It attaches <strong>signature and encryption information</strong> as well as <strong>security tokens</strong> to SOAP messages.</li>
 	<li>In addition to the <strong>traditional HTTP/HTTPS authentications</strong>, it incorporates <strong>extra security features</strong> in the header of the SOAP message, working in the application layer. Also, it ensures end-to-end security.</li>
 	<li>specifications: WS-SecureConversation, WS-Federation, WS-Authorization, WS-Policy, WS-Trust, and WS-Privacy</li>
</ul>
<h3>WS-Reliable Messaging</h3>
<ul>
 	<li>This describes a protocol that allows SOAP messages to be delivered reliably between distributed applications. (enforces reliability between the message source and destination.)</li>
 	<li>If a message cannot be delivered to the destination, the model must raise an exception or indicate to the source that the message can't be delivered.</li>
 	<li>There are several Delivery Assurance options for WS-ReliableMessaging, including <strong>AtLeastOnce, AtMostOnce, ExactlyOnce, and InOrder</strong>.</li>
</ul>
<h3>WS-Coordination and WS-Transaction</h3>
<ul>
 	<li>an extensible framework for <strong>providing protocols</strong> that <strong>coordinate the actions</strong> of distributed applications. The framework enables existing <strong>transaction processing, workflow</strong>, and other systems for coordination, to<strong> hide their proprietary protocols</strong> and to operate in a <strong>heterogeneous environment</strong>.</li>
 	<li>provides a definition for the <strong>structure of the context</strong> and the requirements for<strong> propagating context be-tween cooperating services</strong>.</li>
 	<li>WS-Transaction describes coordination types that are used with the extensible coordination frame-work described in the WS-Coordination specification. It defines two coordination types:<strong> Atomic Trans-action (AT)</strong> b operations and <strong>Business Activity (BA) for long-running</strong> transactions.</li>
</ul>
<strong><b>Address: </b></strong>The address provides two important elements: the location of the service, and the transport protocol. WCF supports the following transport schemas:
<ul>
 	<li> HTTP</li>
 	<li> TCP</li>
 	<li> Peer network</li>
 	<li> IPC (Inter-Process Communication)</li>
 	<li> MSMQ</li>
</ul>
Here are few sample addresses.
<ul>
 	<li>http://localhost:8001</li>
 	<li>http://localhost:8001/TestService</li>
 	<li>net.tcp://localhost:8004/TestService</li>
 	<li>net.pipe://localhost/TestPipe</li>
 	<li>net.msmq://localhost/private/TestQueue</li>
</ul>
&nbsp;

<strong><b>Binding: </b></strong>Bindings are objects that are used to specify the<strong><b> </b></strong>communication details that are required to connect to the endpoint of a WCF service. It is the primary extension point of the ABCs of WCF. Bindings describe the transport protocol, message-encoding format and other messaging protocols for the communication channel. Here are complete list of the standard bindings that come with WCF.

WCF supports nine types of bindings.
<ul>
 	<li><strong>Basic binding</strong>
Offered by the BasicHttpBinding class, this is designed to <strong>expose a WCF service as a legacy ASMX web service</strong>, so that old clients can work with new services. When used by the client, this binding enables new WCF clients to work with old ASMX services.
<strong>TCP binding</strong>
Offered by the NetTcpBinding class, this uses TCP for <strong>cross-machine communication on the intranet</strong>. It supports a variety of features, including reliability, transactions, and security, and is <strong>optimized for WCF-to-WCF</strong> communication. As a result, it <strong>requires both the client and the service to use WCF</strong>.
<strong>Peer network binding</strong>
Offered by the NetPeerTcpBinding class, this uses<strong> peer networking as a transport</strong>. The peer network-enabled client and services all subscribe to the same grid and broadcast messages to it.</li>
 	<li><strong>IPC binding</strong>
<ul>
 	<li>Offered by the NetNamedPipeBinding class, this uses named pipes as a transport for <strong>same-machine communication</strong>. It is the most secure binding since it cannot accept calls from outside the machine and it supports a variety of features similar to the TCP binding.</li>
 	<li>Limitation of Named Pipes in WCF is that it can be used only for interprocess communication on the same machine. So, if your client and service are running on different machines you can't use named pipe based bindings for communication.</li>
</ul>
</li>
 	<li><strong>Web Service (WS) binding</strong> Offered by the WSHttpBinding class, this uses <strong>HTTP or HTTPS</strong> for transport, and is designed to offer a variety of features such as reliability, transactions, and security over the Internet.
<strong>Federated WS binding</strong>
Offered by the WSFederationHttpBinding class, this is a specialization of the WS binding, offering support for <strong>federated security</strong>.
<strong>Duplex WS binding</strong>
Offered by the WSDualHttpBinding class, this is similar to the WS binding except it also supports bidirectional communication from the service to the client.
<strong>MSMQ binding</strong>
Offered by the NetMsmqBinding class, this uses MSMQ for transport and is designed to offer support for disconnected queued calls.
<strong>MSMQ integration binding</strong>
Offered by the MsmqIntegrationBinding class, this converts WCF messages to and from MSMQ messages, and is designed to interoperate with legacy MSMQ clients. <img class="alignnone wp-image-746" src="/wp-content/uploads/2018/03/temp-2-300x183.png" alt="" width="351" height="214" /><img class="alignnone wp-image-747" src="/wp-content/uploads/2018/03/temp-3-300x173.png" alt="" width="366" height="211" /></li>
 	<li>Bindings can be defined in two ways:</li>
</ul>
<strong><b> Declaratively</b></strong>, using service model configuration settings,Here is a declaratively sample:

&nbsp;

&lt;endpoint address="http://localhost:8001/TestService" binding="basicHttpBinding" contract="ITestService" /&gt;

<strong><b> Programmatically</b></strong>, by adding endpoints to the ServiceHost,Here is a programmatically sample:

BasicHttpBinding binding = new BasicHttpBinding(); binding.Security.Mode = BasicHttpSecurityMode.None;

Uri baseAddress = new Uri("http://localhost:8001/TestService");

Uri address = new Uri("http://localhost:8001/TestService/TestService"); ServiceHost serviceHost = new ServiceHost(typeof(TestService), baseAddress); serviceHost.AddServiceEndpoint(typeof(ITestService), binding, address);

In programmatically, As you can see we construct a binding instance and assign its endpoints.

<strong>Binding</strong>
<ul>
 	<li><strong><b>NetTcpBinding </b></strong>is the right choice for binary TCP communications that cross machine boundaries,</li>
 	<li><strong><b>BasicHttpBinding </b></strong>is the right choice for HTTP communications that must support legacy Web service protocols,</li>
 	<li>and <strong><b>WSHttpBinding </b></strong>or<strong><b>WSFederationHttpBinding </b></strong>are the right choice for Web services that can leverage a richer set of standards including those for secure communications (the latter is used for federated security scenarios).</li>
</ul>
<strong><b>Contract: </b></strong>A contract is a description of the messages that are<strong><b> </b></strong>passed to and from service endpoints.

There are three types of contracts in WCF:

<strong><b> Service contracts: </b></strong>Describe which operations the client can<strong><b> </b></strong>perform on the service. It defines some properties about the service, and a set of actions called Operation Contracts.

Operation Contracts are equivalent to web methods in ASMX technology. Here is a sample of service contract.

<strong><b> Data contracts: </b></strong>Data contracts describe data structures that<strong><b> </b></strong>are used by the service to communicate with clients. A data contract maps CLR types to XML Schema Definitions (XSD) and defines how they are serialized and deserialized. Data contracts describe all the data that is sent to or from service operations.

&nbsp;

<strong><b> Message contracts: </b></strong>Message contracts describe the<strong><b> </b></strong>structure of SOAP messages sent to and from a service and enable you to inspect and control most of the details in the SOAP header and body.

&nbsp;

<strong><b>Security</b></strong>

<strong><b>Five possible security modes:</b></strong>
<ul>
 	<li><strong><b>None</b></strong>. Turns security off.</li>
 	<li><strong><b>Transport</b></strong>. Uses transport security for mutual authentication and message protection.</li>
 	<li><strong><b>Message</b></strong>. Uses message security for mutual authentication and message protection.</li>
 	<li><strong><b>Both</b></strong>. Allows you to supply settings for transport and message-level security (only MSMQ supports this).</li>
 	<li><strong><b>TransportWithMessageCredential</b></strong>. Credentials are passed with the message and message protection and server authentication are provided by the transport layer.</li>
 	<li><strong><b>TransportCredentialOnly. </b></strong>Client credentials are passed with the transport layer and no message protection is applied.</li>
</ul>
<a href="http://www.codemag.com/article/0611051"><u>http://www.codemag.com/article/0611051</u></a>  <a href="http://www.codeproject.com/Articles/36732/WCF-FAQ-Part-security-related-FAQ"><u>http://www.codeproject.com/Articles/36732/WCF-FAQ-Part-security-related-FAQ</u></a>

<strong><b>T</b></strong><strong><b>wo aspects</b></strong><strong><b> of WCF security</b></strong>
<ol>
 	<li>Message level = it is independent of the protocol= <strong>encrypting data. WsHTTP with X509 certificates.</strong></li>
 	<li>Channel level /Transport level / Protocol level =  the second is the medium on which the data travels = HTTPS protocol using Certificate</li>
 	<li>Mixed mode. is nothing but a combination of transport and message mode. For instance, data encrypted and passed over <strong>WsHttp using HTTPS is a mixed mode</strong> security. Encryption is nothing but message security and HTTPS is a transport mode. In combination, they form mixed mode.
<table>
<thead>
<tr>
<td valign="top">Binding</td>
<td valign="top">Transport Mode?</td>
<td valign="top">Message Mode?</td>
<td valign="top">Mixed Mode?</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top">BasicHttpBinding</td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top"><span style="color: #0000ff;">Yes</span></td>
</tr>
<tr>
<td valign="top">WsHttpBinding</td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top"><span style="color: #3366ff;"><strong>Yes</strong></span></td>
</tr>
<tr>
<td valign="top">WsDualHttpBinding</td>
<td valign="top"><span style="color: #ff6600;">No</span></td>
<td valign="top">Yes</td>
<td valign="top">No</td>
</tr>
<tr>
<td valign="top">NetTcpBinding</td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top"><span style="color: #3366ff;"><strong>Yes</strong></span></td>
</tr>
<tr>
<td valign="top">NetNamedPipeBinding</td>
<td valign="top">Yes</td>
<td valign="top"><span style="color: #ff6600;">No</span></td>
<td valign="top">No</td>
</tr>
<tr>
<td valign="top">NetMsmqBinding</td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top">No</td>
</tr>
<tr>
<td valign="top">MsmqIntegrationBinding</td>
<td valign="top">Yes</td>
<td valign="top"><span style="color: #ff6600;">No</span></td>
<td valign="top">No</td>
</tr>
</tbody>
</table>
<img class="" src="http://www.codeproject.com/KB/WCF/WCFFAQPart3/3.JPG" width="336" height="280" /></li>
 	<li>WCF uses transport protocols like TCP, HTTP, MSMQ, etc., and each of these protocols have their own security mechanisms.</li>
</ol>
<table>
<tbody>
<tr>
<td width="156"><strong><b> </b></strong></td>
<td width="286"><strong><b>Transport</b></strong></td>
<td width="210"><strong><b>Message</b></strong></td>
</tr>
<tr>
<td width="156">Scenarios when we should be using one of them</td>
<td width="286">When there are no intermediate systems in between to process the data, this is the best methodology.

If it’s an <strong>intranet type of solution, this is the most recommended</strong> methodology.</td>
<td width="210">When there are <strong>intermediate systems like one more WCF service through which message is routed</strong>, then message security is the way to go.</td>
</tr>
<tr>
<td width="156"><strong><b>Advantages</b></strong></td>
<td width="286">Does <strong>not need any extra coding</strong> as protocol inherent security is used.

Performance is better as we can use hardware accelerators to enhance performance.

There is a lot of interoperability support and communicating clients do not need to understand WS security as it’s built in the protocol itself.</td>
<td width="210">Message Security provides <strong>end-to-end security</strong>, in Transport Security where once the message received at server it is not encrypted whereas in Message Level security it is still encrypted.

it’s <strong>not dependent on the protocol (supports all).</strong>

Any intermediate hop in the network does not affect the application. Message security is the o<strong>nly option to provide security when you have intermediate routers</strong> to route request / response.

Message Security provides multiple levels of security meaning that different parts (header, body etc) of message can be secured by different encryption methods.</td>
</tr>
<tr>
<td width="156"><strong><b>Disadvantages</b></strong></td>
<td width="286">As it’s a protocol implemented security, it works only point to point.

As security is dependent on protocol, it has limited security support and is bound to the protocol security limitations.</td>
<td width="210">Needs application refactoring to implement security.

<strong>As every message is encrypted and signed, there are performance issues.</strong>

Does not support interoperability with old ASMX webservices.</td>
</tr>
</tbody>
</table>
<code>
Message security</code>

<code>&lt;wsHttpBinding&gt;</code>
<code> &lt;binding name ="wsMessage"&gt;</code>
<code> &lt;security mode ="Message"&gt;</code>
<code> &lt;message clientCredentialType ="Windows"/&gt;</code>
<code> &lt;/security&gt;</code>
<code> &lt;/binding&gt;</code>
<code> &lt;/wsHttpBinding&gt;</code>

Message security supports any of the following settings for <em><i>clientCredentialType</i></em>:
<ul>
 	<li>None: Messages are secured with encryption however it does not perform any authentication.</li>
 	<li>Windows: Messages are secured with encryption and clients are authenticated using built in Windows Authentication which can be through Active Directory or NTLM.</li>
 	<li>UserName: Messages are secured and encrypted and clients are authenticated by provided UserName and Password.</li>
 	<li>Certificate: Messages are encrypted and both service and clients are authenticated with certificates.</li>
 	<li>IssuedToken: Messages are encrypted and authentication happens through issued tokens by authority like Cardspace.</li>
</ul>
<strong>BasicHttpBinding VS WsHttpBinding</strong>
<ul>
 	<li>If you are looking for backwards compatibility and to support lots of clients, then basic HTTP binding is the way to go, or else WsHttp is a great way to start if you are seeing your clients made in .NET 3.0 and above.</li>
 	<li>One of the biggest differences you must have noticed is the security aspect. By default, 'BasicHttpBinding' sends data in plain text while ‘WsHttpBinding’ sends in an encrypted and secured manner.</li>
</ul>
<table style="width: 651px;">
<tbody>
<tr>
<td style="width: 90px;"><strong><b>Criteria</b></strong></td>
<td style="width: 294px;"><strong><b>BasicHttpBinding</b></strong></td>
<td style="width: 250px;"><strong><b>WsHttpBinding</b></strong></td>
</tr>
<tr>
<td style="width: 90px;">Security support</td>
<td style="width: 294px;">This supports the old ASMX style, i.e., WS-BasicProfile 1.1.</td>
<td style="width: 250px;">This exposes web services using WS-* specifications.</td>
</tr>
<tr>
<td style="width: 90px;">Compatibility</td>
<td style="width: 294px;">This is aimed for clients who do not have .NET 3.0 installed and it supports wider ranges of clients. Many clients like Windows 2000 still do not run .NET 3.0. So an older version of .NET can consume this service.</td>
<td style="width: 250px;">As it is built using WS-* specifications, it does not support wider ranges of clients and it cannot be consumed by older .NET versions less than version 3.</td>
</tr>
<tr>
<td style="width: 90px;">SOAP version</td>
<td style="width: 294px;">SOAP 1.1</td>
<td style="width: 250px;">SOAP 1.2 and WS-Addressing specification.</td>
</tr>
<tr>
<td style="width: 90px;">Reliable messaging</td>
<td style="width: 294px;">Not supported. In other words, if a client fires two or three calls, you really do not know they will return back in the same order.</td>
<td style="width: 250px;">Supported as it supports WS-* specifications.</td>
</tr>
<tr>
<td style="width: 90px;">Default security options</td>
<td style="width: 294px;"><u>By default</u>, there is no security provided for messages when the client calls happen. In other words, <u>data is sent as plain text</u>.</td>
<td style="width: 250px;">As WsHttBinding supports WS-*, it has WS-Security enabled by default. So the data is not sent as plain text.</td>
</tr>
<tr>
<td style="width: 90px;">Security options</td>
<td style="width: 294px;">
<ul>
 	<li>None</li>
 	<li><strong>Windows – default authentication</strong></li>
 	<li>Basic</li>
 	<li>Certificate</li>
</ul>
</td>
<td style="width: 250px;">
<ul>
 	<li>None</li>
 	<li>Transport</li>
 	<li>Message</li>
 	<li>Transport with message credentials</li>
</ul>
</td>
</tr>
</tbody>
</table>
&nbsp;

<strong><b>Instance management</b></strong>

Instance <a href="http://www.codeproject.com/Articles/86007/ways-to-do-WCF-instance-management-Per-call-Per"><u>http://www.codeproject.com/Articles/86007/ways-to-do-WCF-instance-management-Per-call-Per</u></a>
<h2>How to set the instancing mode in WCF service?</h2>
In WCF, instancing mode is set at service level. For ex.
<code>//Setting PerSession instance mode </code>
<code>[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)] </code>
<code>class MyService : IMyService </code>
<code>{ </code>
<code>//Implementation goes there </code>
<code>}</code>

&nbsp;

WCF client makes a request to a WCF service object.

WCF service object is instantiated.

WCF service instance serves the request and sends the response to the WCF client.

Following is a pictorial representation of how WCF requests and responses work.

Following are different ways by which you can create WCF instances:

Create a new WCF service instance on every WCF client method call.

Only one WCF service instance should be created for every WCF client session.

Only one global WCF service instance should be created for all WCF clients.

To meet the above scenarios, WCF has provided three ways by which you can control WCF service instances:

Per call

Per session

Single instance

&nbsp;

&nbsp;

[ServiceBehavior(InstanceContextMode = InstanceContextMode.Percall)]

public class Service : IService

&nbsp;

[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]

&nbsp;

[ServiceBehavior(InstanceContextMode = InstanceContextMode.Single)]

&nbsp;
<h3>Per call</h3>
You want a stateless services.

Your service holds intensive resources like connection objects and huge memory objects.

Scalability is a prime requirement. You would like to have a scaled out architecture.

Your WCF functions are called in a single threaded model.
<h3>Per session</h3>
You want to maintain states between WCF calls.

You a scaled up architecture.

Light resource references.
<h3>Single</h3>
You want share global data through your WCF service.

Scalability is not a concern.

&nbsp;

&nbsp;

&nbsp;

<strong><b>Concurrency management </b></strong>

&nbsp;

<a href="http://www.codeproject.com/Articles/89858/WCF-Concurrency-Single-Multiple-and-Reentrant-and"><u>http://www.codeproject.com/Articles/89858/WCF-Concurrency-Single-Multiple-and-Reentrant-and</u></a>

&nbsp;

WCF concurrency helps us configure how WCF service instances can serve multiple requests at the same time. You will need WCF concurrency for the below prime reasons; there can be other reasons as well but these stand out as important reasons:

<strong><b>Increase throughput</b></strong>: Many times you want to increase the amount of work your WCF service instance does at any moment of time. In other words, you would like to increase the throughput. Throughput means how much work a given thing can do.

By default, a WCF service handles only one request at a given moment of time.

<strong><b>Integration with a legacy system</b></strong>: Many times your WCF services interact with legacy systems like VB6, COM, etc. It’s very much possible that these systems are not multithreaded, in other words they handle only one request at any given time. So even though your WCF service has concurrent capabilities, you would still like to handle one request at a time. This is achieved by using throttling in combination with WCF concurrency capabilities.

<strong><b>Single</b></strong>: A s<u>ingle request has access to the WCF service object </u>at a given moment of time. So only one request will be processed at any given moment of time. The other requests have to wait until the request processed by the WCF service is completed.

<strong><b>Multiple</b></strong>: In this scenario, multiple requests can be handled by the WCF service object at any given moment of time. In other words, <strong><b>requests are processed at the same time by spawning multiple threads on the WCF server object.</b></strong> So you have great throughput here but you need to ensure concurrency issues related to WCF server objects.

<strong><b>Reentrant</b></strong>: A single request thread has access to the WCF service object, but the thread can exit the WCF service to call another WCF service or can also call a WCF client through callback and reenter without deadlock.
<table>
<tbody>
<tr>
<td rowspan="2" width="116"><strong><b>InstanceContext</b></strong><strong><b>
</b></strong><strong><b>Mode</b></strong></td>
<td colspan="3" width="535"><strong><b>ConcurrencyMode</b></strong></td>
</tr>
<tr>
<td width="141"><strong><b>Single (Default)</b></strong></td>
<td width="154"><strong><b>Multiple</b></strong></td>
<td width="239"><strong><b>Reentrant</b></strong></td>
</tr>
<tr>
<td width="116">Single
(Single instance for all clients)</td>
<td width="141">Single thread for all clients.</td>
<td width="154">Multiple threads for all clients.</td>
<td rowspan="3" width="239">Single threads for all clients, locks are released when calls diverted to other WCF services.</td>
</tr>
<tr>
<td width="116">PerSession (Default)聽
(Multiple instance per client)</td>
<td width="141">Single thread for every client.</td>
<td width="154">Multiple threads for every request.</td>
</tr>
<tr>
<td width="116">PerCall (Multiple instances for every method call)</td>
<td width="141">Single thread for every client.</td>
<td width="154">Single thread for every client</td>
</tr>
</tbody>
</table>
<h2><strong><b>Throttling behavior</b></strong></h2>
MaxConcurrentCalls: Limits the number of concurrent requests that can be processed by WCF service instances.

MaxConcurrentInstances: Limits the number of service instances that can be allocated at a given time. When it’s PerCall services, this value matches the number of concurrent calls. For PerSession services, this value equals the number of active session instances. This setting doesn’t matter for Single instancing mode, because only one instance is ever created.

MaxConcurrentSessions: Limits the number of active sessions allowed for the service.
<h2><strong><b>Default values for WCF throttling</b></strong></h2>
Below is a simple table which shows the default settings for throttling for different WCF versions:
<table>
<tbody>
<tr>
<td width="86"><strong><b> </b></strong></td>
<td width="193"><strong><b>MaxConcurrentSessions</b></strong></td>
<td width="195"><strong><b>MaxConcurrentCalls </b></strong></td>
<td width="177"><strong><b>MaxConcurrentInstances </b></strong></td>
</tr>
<tr>
<td width="86">WCF 3.0 / 3.5</td>
<td width="193">6</td>
<td width="195">26</td>
<td width="177">10</td>
</tr>
<tr>
<td width="86">WCF 4.0</td>
<td width="193">16 * processorcount MaxConcurrentCalls</td>
<td width="195">MaxConcurrentCalls
+
MaxConcurrentSessions 100 * processorcount</td>
<td width="177">100 * processorcount</td>
</tr>
</tbody>
</table>
&nbsp;

References
<ul>
 	<li>http://www.dotnettricks.com/learn/webservice/understanding-ws-star-standards-and-specifications</li>
 	<li>http://www.c-sharpcorner.com/UploadFile/8a67c0/different-types-of-binding-in-wcf/</li>
 	<li>https://sites.google.com/site/wcfpandu/home/wcf-all-security-related-faq</li>
 	<li>https://sites.google.com/site/wcfpandu/home/silvarlight</li>
 	<li>http://dotnetmentors.com/wcf/wcf-message-level-security-by-example.aspx</li>
</ul>
