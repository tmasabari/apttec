---
layout: post
title: Token Authentication and .NET
date: 2018-08-01 11:56
author: tmasabari
comments: true
categories: [Uncategorized]
---
<ul>
 	<li>https://blogs.msdn.microsoft.com/webdev/2016/10/27/bearer-token-authentication-in-asp-net-core/</li>
 	<li>ASP.NET Core <a href="https://docs.asp.net/en/latest/security/authentication/identity.html">Identity</a> automatically supports cookie authentication.</li>
 	<li>It is also straightforward to support authentication by <a href="https://docs.asp.net/en/latest/security/authentication/sociallogins.html">external providers</a>using the <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google/">Google</a>, <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook/">Facebook</a>, or <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter/">Twitter</a> ASP.NET Core authentication packages.
<p id="TDTLcFo"><img class="alignnone size-full wp-image-1631 " src="/wp-content/uploads/2018/07/img_5b6074d0cb774.png" alt="" /></p>
</li>
 	<li>The customer has a local server with business information which will need to be accessed and updated periodically by client devices.</li>
 	<li>Rather than store user names and hashed passwords locally, the customer prefers to use a common authentication micro-service which is hosted in Remote network (Azure) and used in many scenarios beyond just this specific one.</li>
 	<li>This particular scenario is interesting, though, because the connection between the customer’s location (where the server and clients reside) and the internet is not reliable.</li>
 	<li>Therefore, they would like a user to be able to authenticate at some point in the morning when the connection is up and have a token that will be valid throughout that user’s work shift.</li>
 	<li>The local server, therefore, needs to be able to <strong>validate the token without access to the Azure authentication service.</strong></li>
 	<li>This local validation is easily accomplished with <a href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWT tokens</a>. A JWT token typically contains a body with information about
<ol>
 	<li>the authenticated user (subject identifier, claims, etc.),</li>
 	<li>the issuer of the token,</li>
 	<li>the audience (recipient) the token is intended for, and</li>
 	<li>an expiration time (after which the token is invalid).</li>
 	<li>The token also contains a cryptographic signature as detailed in <a href="https://tools.ietf.org/html/rfc7518">RFC 7518</a>.</li>
</ol>
</li>
 	<li>This signature is generated by a <strong>private key known only to the authentication</strong> server, but can be <strong>validated by anyone in possession of the corresponding public</strong> key.</li>
 	<li>One JWT validation work flow (used by AD and some identity providers) involves requesting the public key from the issuing server and using it to validate the token’s signature.</li>
 	<li>In our offline scenario, though, the <strong>local server can be prepared with the necessary public key ahead of time.</strong></li>
 	<li>The challenge with this architecture is that the local server will need to be given an updated public key anytime the private key used by the cloud service changes, but this inconvenience means that no internet connection is needed at the time the JWT tokens are validated.</li>
</ul>
authentication server
<ul>
 	<li><a href="https://github.com/IdentityServer/IdentityServer4">IdentityServer4</a> is a flexible OpenID Connect framework for ASP.NET Core.</li>
 	<li>Another good option is <a href="https://github.com/openiddict/openiddict-core">OpenIddict</a>. Like IdentityServer4, OpenIddict offers OpenID Connect server functionality for ASP.NET Core.</li>
 	<li>Both OpenIddict and IdentityServer4 work well with ASP.NET Identity 3.</li>
 	<li>Please note that <strong><em>both IdentityServer4 and OpenIddict are pre-release packages currently</em></strong>.</li>
</ul>
<h4>Adding Roles</h4>
<ul>
 	<li>ASP.NET Identity 3 includes the concept of <a href="https://docs.asp.net/en/latest/security/authorization/roles.html?highlight=roles">roles</a>.</li>
 	<li>To take advantage of this, we need to create some roles which users can be assigned to.</li>
 	<li>In a real application, this would likely be done by managing roles through a web interface.</li>
</ul>
&nbsp;

&nbsp;
