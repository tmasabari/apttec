---
layout: post
title: 4 0 2 WebAPI.docx
date: 2018-03-20 17:27
author: tmasabari
comments: true
categories: [Uncategorized]
---
<h1><strong>Web API Design Book</strong></h1>
<p><u><a href="http://www.infoq.com/news/2012/03/web-api-design-book" target="_blank">http://www.infoq.com/news/2012/03/web-api-design-book</a></u> </p>
<p>The goal is to make sure that your API is intuitive and easy to use for the app developer.</p>
<h2><strong>Nouns. </strong></h2>
<p>Use nouns instead of verbs in your base URLs, and keep them simple by using two base URLs per resource. Use HTTP verbs (GET, POST, PUT and DELETE) to operate on collections and elements. <u>Use plural rather than singular nouns. Use concrete rather than abstract names.</u> For example, here's how to get all dogs and a specific dog.</p>
<p>        GET /dogs</p>
<p>        GET /dogs/1</p>
<p>The book discusses options when the client does not support all the different HTTP methods.</p>
<p>Our HTTP verbs are POST, GET, PUT, and DELETE. (We think of them as mapping to the acronym, CRUD (Create-Read-Update-Delete).)</p>
<p><img src="/wp-content/uploads/2018/03/image1-5.png" class="wp-image-1164" alt="image1 5"></p>
<p>Concrete names are better than abstract Achieving pure abstraction is sometimes a goal of API architects. However, that abstraction is not always meaningful for developers.  </p>
<h3><strong>When a client supports limited HTTP methods</strong></h3>
<p>It is common to see support for GET and POST and not PUT and DELETE</p>
<p>Then the HTTP verb is always a GET but the developer can express rich HTTP verbs and still maintain a RESTful clean API. </p>
<p><strong>Create</strong> /dogs?method=post </p>
<p><strong>Read</strong> /dogs </p>
<p><strong>Update</strong> /dogs/1234?method=put&amp;location=park </p>
<p><strong>Delete</strong> /dogs/1234?method=delete </p>
<p><strong>WARNING</strong>: It can be <strong>dangerous</strong> to provide post or delete capabilities using a GET method because if the URL is in a Web page then a <strong>Web crawler like the Googlebot</strong> can create or destroy lots of content inadvertently. Be sure you understand the implications of supporting this approach for your applications' context</p>
<h2><strong>Verbs. </strong></h2>
<p>If your API is sending a response that is not a resource, then it makes better sense to use verbs instead of nouns. Make it clear in your API documentation that these non-resource based APIs are different from the rest of the API. Here's an API call for converting 100 Euros to Chinese Yen.</p>
<p>        /convert?from=EUR&amp;to=CNY&amp;amount=100</p>
<h2><strong>Associations. </strong></h2>
<p>Resources almost always have relationships to other resources. What's a simple way to express these relationships in a Web API? Simplify the associations between resources and avoid deep URL levels. Move complexity like parameters and attributes after the HTTP question mark. Here's how we can get all dogs belonging to particular owner, and just the black ones.</p>
<p>        GET /owners/1/dogs</p>
<p>        GET /owners/1/dogs?color=black</p>
<h3><strong>Sweep complexity behind the ‘?’</strong></h3>
<p>Complexities can include many states that can be updated, changed, queried, as well as the attributes associated with a resource.</p>
<p>To get all red dogs running in the park: </p>
<p><strong>GET /dogs?color=red&amp;state=running&amp;location=park</strong></p>
<h2><strong>Errors. </strong></h2>
<p>From the perspective of the developer consuming your Web API, everything at the other side of that interface is a black box. Errors therefore become a key tool providing context and visibility into how to use an API. (Especially for "test driven development" models)</p>
<p>Use HTTP status codes. The usual suspects include HTTP 200, 400, 401, 403, 404, and 500. Make the messages returned in the payload as verbose as possible. Here's an example JSON payload. Notice the use of URLs for more information.</p>
<p>        {</p>
<p>        "developerMessage" : "...",</p>
<p>        "userMessage" : "...",</p>
<p>        "errorCode" : 100,</p>
<p>        "moreInfo": "http://developers.company.com/errors/100"</p>
<p>        }</p>
<p>The book discusses options when the client always expects a HTTP 200, like some versions of Adobe Flash.</p>
<p>There are over <u><a href="http://en.wikipedia.org/wiki/Http_error_codes" target="_blank">70 HTTP status codes</a></u>. However, most developers don't have all 70 memorized. So if you choose status codes that are not very common you will force application developers away from building their apps and over to Wikipedia to figure out what you're trying to tell them. Therefore, most API providers use a small subset. For example, the Google GData API uses only 10 status codes; Netflix uses 9, and Digg, only 8.</p>
<p>How many status codes should you use for your API? When you boil it down, there are really only 3 outcomes in the interaction between an app and an API: </p>
<p>• Everything worked - success </p>
<p>• The application did something wrong – client error </p>
<p>• The API did something wrong – server error </p>
<p>But you shouldn't need to go beyond 8. </p>
<p>• 200 - OK • 400 - Bad Request  • 500 - Internal Server Error </p>
<p>If you're not comfortable reducing all your error conditions to these 3, try picking among these additional 5: </p>
<p>• 201 - Created • 304 - Not Modified • 404 – Not Found • 401 - Unauthorized • 403 - Forbidden </p>
<h3><strong>Tips for handling exceptional behaviour</strong></h3>
<p>Some applications (like some versions of flash) will not provide an opportunity to intercept the error code to developers if you send an HTTP response that is anything other than HTTP 200 OK.</p>
<p>Overall recommendations: 1 - Use suppress_response_codes = true 2 - The HTTP code is no longer just for the code</p>
<p>3 - Push any response code that we would have put in the HTTP response down into the response message</p>
<p><strong>Always return OK </strong>/dogs?suppress_response_codes = true </p>
<p><strong>Code for ignoring</strong> 200 - OK </p>
<p><strong>Message for people &amp; code </strong></p>
<p>{response_code" : 401, "message" : "Verbose, plain language description of the problem with hints about how to fix it." "more_info" : "http://dev.tecachdogrest.com/errors/12345", "code" : 12345}</p>
<h2><strong>Versions. </strong></h2>
<p>Make versioning in your API mandatory. Specify the version with a 'v' prefix and put it on the first level. Don't use the dot notation like v1.2 because it implies a granularity of versioning . Use a simple ordinal number to emphasize this is an interface and not an implementation. Here's an example of getting all dogs for version 1 of your API.</p>
<p>        GET /v1/dogs</p>
<h2><strong>Header Vs URL</strong></h2>
<p>In fact, using headers is more correct for many reasons: it leverages existing HTTP standards, it's intellectually consistent with Fielding's vision, it solves some hard realworld problems related to inter-dependent APIs, and more. However, we think the reason most of the popular APIs do not use it is because it's less fun to hack in a browser. Simple rules we follow: If it changes the logic you write to handle the response, put it in the URL so you can see it easily. If it doesn't change the logic for each response, like OAuth information, put it in the header.</p>
<h2><strong>Partial Response and Pagination. </strong></h2>
<p>Use a comma-delimited list to specify what fields you want returned. Use "limit" and "offset" to paginate through resources. These parameters are common and well understood in databases. Here's how to get just the colors and breeds of all the dogs, and the just first 10 dogs.</p>
<p><strong>My loose rule of thumb for default pagination is limit=10 with offset=0.<br></strong><strong>The pagination defaults are of course dependent on your data size. If your resources are large, you probably want to limit it to fewer than 10; if resources are small, it can make sense to choose a larger limit.</strong></p>
<p>        GET /dogs?fields=color,breed</p>
<p>        GET /dogs?limit=10&amp;offset=0</p>
<h2><strong>Content-Types. </strong></h2>
<p>It's recommended that APIs support different response formats like JSON and XML. To specify what format to return, use the dot type notation. </p>
<p><strong>Make JSON the default format, as it is less verbose and can be easily consumed by JavaScript. Here's how to get all dogs in XML.</strong></p>
<p>        GET /dogs/1.xml</p>
<h2><strong>Attributes. </strong></h2>
<p>Use JSON as default. Follow JavaScript conventions for naming attributes. Use CamelCase, the first letter being uppercase or lowercase depending on type of object. Here's an example of a user ID attribute.</p>
<p>        {</p>
<p>        "userId": 1</p>
<p>        }</p>
<h2><strong>Search. </strong></h2>
<p>To do a search across multiple resources, use the verb "search" and the "q" query parameter. Specify the format type using dot type notation. Here's an example of searching for all fluffy resources, in the default and XML formats.</p>
<p>        GET /search?q=fluffy</p>
<p>        GET /search.xml?q=fluffy</p>
<p>To add scope to your search, you can use a resourceful URL with the query parameter. For example, here's searching for all dogs belonging to a particular owner that are fluffy.</p>
<p>        GET /owners/1/dogs?q=fluffy</p>
<h2><strong>Subdomains. </strong></h2>
<p>Consolidate all API requests under one API subdomain. Use something like api.company.com. Also create a dedicated developer portal like developers.company.com. You might also want to redirects users who go to the API subdomain in their browsers to the developer portal.</p>
<p>Your API gateway should be the top-level domain. For example, api.teachdogrest.com</p>
<h2><strong>Authentication. </strong></h2>
<p>Use the <strong>latest</strong> standard OAuth (current is 2.0). It allows API access without sharing of passwords. It allows API providers to revoke access tokens. It allows developers to use the same OAuth libraries they use for other APIs.</p>
<ul>
<li>It means that Web or mobile apps that expose APIs don’t have to share passwords. </li>
<li>It allows the API provider to revoke tokens for an individual user, for an entire app, without requiring the user to change their original password. </li>
<li>This is critical if a mobile device is compromised or if a rogue app is discovered.</li>
<li>Above all, OAuth 2.0 will mean improved security and better end-user and consumer experiences with Web and mobile apps.</li>
</ul>
<h2><strong>Chatty APIs. </strong></h2>
<p>Some API designs become very chatty, which means you need a lot of API calls to the server to build a simple application. The recommendation is to create a complete and RESTful API and provide shortcuts or composite responses if needed.</p>
<p><strong>What kind of shortcut? Say you know that 80% of all your apps are going to need some sort of composite response, then build the kind of request that gives them what they need.</strong></p>
<h2><strong>SDK. </strong></h2>
<p>It's recommended that API providers complement the API with code samples, libraries and software development kits. It allows for faster adoption on specific platforms. It helps reduce bad or inefficient code that might slow down the service. It helps market the API to different developer communities.</p>
<h2><strong>API Facade. </strong></h2>
<h3><strong>Stakeholders</strong></h3>
<p><strong>Who are the people in that system - in the API value chain? </strong>The key players include the API team and the app developers.</p>
<p><img src="/wp-content/uploads/2018/03/image3-2.png" class="wp-image-1160" alt="image3 2"></p>
<h3><strong>The need</strong></h3>
<ul>
<li>Going back to our API value chain, app developers build apps using the APIs provided by the API Team (API provider). Everybody wins if app developers are as productive as possible and adopt your API quickly. </li>
<li>Those app developers will help build the value within your organization and to extend that value proposition out beyond the boundaries of your organization into the broader market.</li>
<li>This pattern gives you a virtual layer between the interface on top and the API implementation on the bottom. It is a comprehensive view of what the API should be.</li>
<li>Importantly, it is the view from the perspective of the app developer and end user of the apps they create.</li>
<li>You break one major problem (exposing a set of complex internal systems in such a way as to be beneficial for developers) into three smaller problems (designing the ideal API; implementing the design with data stubs; integrating between the façade and the systems).</li>
<li>It also has benefits internally (behind the façade) in that it enables an API team to create an extensible API that allows new systems to be plugged in, allowing your organization to keep pace with both the marketplace and with changing internal systems.</li>
</ul>
<p>There are various ways in architecting your API. The recommended approach is called the "API Facade Pattern", which involves three basic steps.</p>
<ol>
<li>Design the ideal API. Design the URLs, parameters, responses, payloads, headers, and so on. The API design should be self-consistent</li>
<li>Implement with stubs. This allows developers to use the API and give feedback even before the API is connected to internal systems.</li>
<li>Integrate the Facade and the internal systems.</li>
</ol>
<p><img src="/wp-content/uploads/2018/03/image2-2.png" class="wp-image-1158" alt="image2 2"></p>
<p><img src="/wp-content/uploads/2018/03/image4-1.png" class="wp-image-1162" alt="image4 1"></p>
<h3><strong>The API Team</strong></h3>
<p><img src="/wp-content/uploads/2018/03/image6-2.png" class="wp-image-1161" alt="image6 2"></p>
<p>The core of that team includes <strong>architects</strong>, <strong>software engineers</strong>, <strong>operations professionals</strong>, <strong>QA engineers </strong>and <strong>database administrators</strong>. But don’t stop there.</p>
<p>The four main persona of app developer we talk about depends on what kind of API strategy you have – whether <strong>internal</strong>, <strong>partner</strong>, <strong>customer</strong>, or <strong>open</strong>.</p>
<p><br><strong>Internal</strong>: The app developer using the API works for the company – the API provider.<br><strong>Partner</strong>: The developer works for or is a strategic partner. The go-to-market strategy is one with a shared value proposition.<br><strong>Customer</strong>: The “customer developer” is especially important if your organization is a SaaS provider or if a large amount of revenue comes from B2B customers as opposed to consumer end users.<br><strong>Open</strong>: The developer in this case is any developer who signs up to build apps against your API.</p>
<p><strong>Technology for Authorization - OAuth</strong></p>
<ul><li>Let's look at how to handle authorization through the API facade. A request comes into the facade with an OAuth token or other indications of the authorization scheme.</li></ul>
<ul>
<li>The facade can make the calls to the authorization system of record.</li>
<li>If the request is valid, the facade passes it to the core system; if invalid, the façade returns with an invalid response code.</li>
</ul>
<p><img src="/wp-content/uploads/2018/03/image5-3.png" class="wp-image-1177" alt="image5 3"></p>
<h2><strong>OAuth Vs OWIN</strong></h2>
<p>OAuth 2.0 specifies four roles, </p>
<ol>
<li>Resource Owner, (user)</li>
<li>Client, (application)</li>
<li>Resource Server (service like Twitter or Facebook etc) and </li>
<li>Authorization Server.</li>
</ol>
<h2><strong>The OAuth 2.0 flow</strong></h2>
<p><img src="/wp-content/uploads/2018/03/image8-2.png" class="wp-image-1163" alt="image8 2"></p>
<h3>Terms you should know</h3>
<ul>
<li>
<strong>Client</strong> -- Also called "the app". It can be an app running on a mobile device or a traditional web app. The app makes requests to the resource server for protected assets on behalf of the resource owner. The resource owner must give the app permission to access the protected resources. </li>
<li>
<strong>Resource owner</strong> -- Also called an "end user". This is generally the person (or other entity) who is capable of granting access to a protected resource. For example, if an app needs to use data from one of your social media sites, then you are the resource owner -- the only person who can grant the app access to your data.</li>
<li>
<strong>Protected resource</strong> -- Data owned by the resource owner. For example, the user's contact list, account information, or other sensitive data. <ul><li>
<strong>Limited Access<br></strong>Through the mechanism of scopes, OAuth 2.0 can grant an app limited access to protected resources. For example, an app may have access only to specific resources, may be able to update resources, or may only be granted read-only access. Under so-called "three-legged" OAuth flows, the user typically specifies the level of access through a consent page (for example, a web page where the user selects the scope with a checkbox of other mechanism). </li></ul>
</li>
<li>
<strong>Resource server</strong> -- Think of the resource server as a service like Twitter or Facebook, or an HR service on your intranet, or a partner service on your B2B extranet. Apigee Edge is a resource server whenever OAuth token validation is required to process API requests. The resource server needs some kind of authorization before it will serve up protected resources to the app. </li>
<li>
<strong>Authorization server </strong>-- The authorization server is implemented in compliance with the OAuth 2.0 specification, and it is responsible for validating <strong>authorization grants</strong> and issuing the <strong>access tokens </strong>that give the app access to the user's data on the resource server. <br><ul><li>All clients (apps) must register with the OAuth 2.0 authorization server from which they intend to request access tokens. When you register an app, you receive back a set of keys. One is a public key called the client identifier, and the other is a secret key called the client secret. Without these keys, an app cannot issue requests for authorization codes or access tokens to the authorization server. </li></ul>
</li>
<li>
<strong>Access token</strong> -- A long string of characters that serves as a credential used to access protected resources. </li>
</ul>
<p><em>Resources tokens (also called bearer tokens) are passed in Authorization headers, like this:</em></p>
<p><strong>$ curl -H "Authorization: Bearer UAj2yiGAcMZGxfN2DhcUbl9v8WsR" \</strong></p>
<p><strong>  http://myorg-test.apigee.net/v0/weather/forecastrss?w=12797282</strong></p>
<p><em>The resource server understands that the access token "stands in" for credentials like username and password. In addition, the access tokens can be issued with restrictions, so that, for example, the app can read but not write or delete data on the resource server. Note that an access token can be revoked if, for instance, the app is compromised. In this case, you will need to get a new access token to continue using the app; however, you will not have to change your username or password on the protected resources server (for example, Facebook or Twitter). </em></p>
<p><em>Access tokens generally have an expiration (for security reasons). Some grant types allow the authorization server to issue an refresh token, which allows the app to fetch a new access token when the old one expires.</em></p>
<ul><li>
<strong>Authorization grant</strong> -- Gives the app permission to retrieve an access token on behalf of the end user. OAuth 2.0 defines four specific "grant types". See "<u><a href="http://docs.apigee.com/api-services/content/oauth-introduction#granttypes" target="_blank">What are the OAuth 2.0 grant types</a></u>" below. </li></ul>
<h1><strong>CORS</strong></h1>
<p><u><a href="https://msdn.microsoft.com/en-us/magazine/dn532203.aspx" target="_blank">https://msdn.microsoft.com/en-us/magazine/dn532203.aspx</a></u></p>
<p><u><a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/enabling-cross-origin-requests-in-web-api" target="_blank">https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/enabling-cross-origin-requests-in-web-api</a></u> </p>
<p><a href="http://www.w3.org/TR/cors/" target="_blank">Cross Origin Resource Sharing</a> (CORS) is a W3C standard that allows a server to relax the same-origin policy. Using CORS, a server can explicitly allow some cross-origin requests while rejecting others.</p>
<p>Two URLs have the same origin if they have identical schemes, hosts, and ports. (<a href="http://tools.ietf.org/html/rfc6454" target="_blank">RFC 6454</a>)</p>
<p>Internet Explorer does not consider the port when comparing origins.</p>
<ul>
<li>http://example.net - Different domain</li>
<li>http://example.com:9000/foo.html - Different port</li>
<li>https://example.com/foo.html - Different scheme</li>
<li>http://www.example.com/foo.html - Different subdomain</li>
</ul>
<p><img src="/wp-content/uploads/2018/03/image7-2.png" class="wp-image-1159" alt="image7 2"></p>
<p>The general mechanics of CORS are such that when JavaScript is attempting to make a cross-origin AJAX call the browser will “ask” the server if this is allowed by sending headers in the HTTP request (for example, Origin). The server indicates what’s allowed by returning HTTP headers in the response (for example, Access-Control-Allow-Origin). This permission check is done for each distinct URL the client invokes, which means different URLs can have different permissions.</p>
<p>Browsers can ask the server for these permissions in two different ways: </p>
<p><strong>simple CORS requests and preflight CORS requests.</strong></p>
<table><tbody>
<tr>
<td><p>Permission/Feature</p></td>
<td><p>Request Header</p></td>
<td><p>Response Header</p></td>
</tr>
<tr>
<td><p>Origin</p></td>
<td><p>Origin</p></td>
<td><p>Access-Control-Allow-Origin</p></td>
</tr>
<tr>
<td><p>HTTP method</p></td>
<td><p>Access-Control-Request-Method</p></td>
<td><p>Access-Control-Allow-Method</p></td>
</tr>
<tr>
<td><p>Request headers</p></td>
<td><p>Access-Control-Request-Headers</p></td>
<td><p>Access-Control-Allow-Headers</p></td>
</tr>
<tr>
<td><p>Response headers</p></td>
<td><p> </p></td>
<td><p>Access-Control-Expose-Headers</p></td>
</tr>
<tr>
<td><p>Credentials</p></td>
<td><p> </p></td>
<td><p>Access-Control-Allow-Credentials</p></td>
</tr>
<tr>
<td><p>Cache preflight response</p></td>
<td><p> </p></td>
<td><p>Access-Control-Max-Age</p></td>
</tr>
</tbody></table>
<h1><a href="https://stackoverflow.com/questions/39613831/how-to-solve-asp-net-web-api-cors-preflight-issue-when-using-put-and-delete-requ" target="_blank">How to solve ASP.NET Web API CORS Preflight issue when using PUT and DELETE requests with multiple origins?</a></h1>
<h1><strong>https://stackoverflow.com/questions/39613831/how-to-solve-asp-net-web-api-cors-preflight-issue-when-using-put-and-delete-requ</strong></h1>
<p>protected void Application_BeginRequest(){</p>
<p>    if (Request.HttpMethod == "OPTIONS")</p>
<p>    {</p>
<p>        Response.StatusCode = (int)HttpStatusCode.OK;</p>
<p>        Response.AppendHeader("Access-Control-Allow-Origin", Request.Headers.GetValues("Origin")[0]);</p>
<p>        Response.AddHeader("Access-Control-Allow-Headers", "Content-Type, Accept");</p>
<p>        Response.AddHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE");</p>
<p>        Response.AppendHeader("Access-Control-Allow-Credentials", "true");</p>
<p>        Response.End();</p>
<p>    }}</p>
<p>Since I have different origins calling my web API, I'm using Request.Headers.GetValues("Origin")[0]) to set the origin in the response dinamically.</p>
<p>In the WebApiConfig.cs I still specified the different origins but used wildcards on the headers and methods, as well as setting the SupportsCredentials to true, like this:</p>
<p>var cors = new EnableCorsAttribute("http://localhost:63342,http://localhost:63347,http://localhost:63345", "*", "*");</p>
<p>cors.SupportsCredentials = true;</p>
<p>config.EnableCors(cors);</p>
<p>// TODO: Replace with the URL of your WebService app</p>
<p>    var serviceUrl = 'http://mywebservice/api/test'; </p>
<p>    function sendRequest() {</p>
<p>        var method = $('#method').val();</p>
<p>        $.ajax({</p>
<p>            type: method,</p>
<p>            url: serviceUrl</p>
<p>        }).done(function (data) {</p>
<p>            $('#value1').text(data);</p>
<p>        }).error(function (jqXHR, textStatus, errorThrown) {</p>
<p>            $('#value1').text(jqXHR.responseText || textStatus);</p>
<p>        });</p>
<p>}</p>
<p>Install-Package Microsoft.AspNet.WebApi.Cors</p>
<p>public static class WebApiConfig</p>
<p>    {</p>
<p>        public static void Register(HttpConfiguration config)</p>
<p>        {</p>
<p>            // New code</p>
<p>            config.EnableCors();</p>
<p>            config.Routes.MapHttpRoute(</p>
<p>                name: "DefaultApi",</p>
<p>                routeTemplate: "api/{controller}/{id}",</p>
<p>                defaults: new { id = RouteParameter.Optional }</p>
<p>            );</p>
<p>        }</p>
<p>    }</p>
<p><strong>Global</strong></p>
<p>The parameters (in order) are:</p>
<ol>
<li>List of origins allowed</li>
<li>List of request headers allowed</li>
<li>List of HTTP methods allowed</li>
<li>List of response headers allowed (optional)</li>
</ol>
<p>public static class WebApiConfig </p>
<p>{ </p>
<p>public static void Register(HttpConfiguration config) </p>
<p>{ </p>
<p>var cors = new EnableCorsAttribute("www.example.com", "*", "*");                 </p>
<p>config.EnableCors(cors); // ... </p>
<p>} </p>
<p>}</p>
<p><strong>Class level</strong></p>
<p>[EnableCors(origins: "http://mywebclient.azurewebsites.net", headers: "*", methods: "*")] </p>
<p>public class TestController : ApiController</p>
<p><strong>Method level</strong></p>
<p>[EnableCors(origins: "http://www.example.com", headers: "*", methods: "*")] </p>
<p>public HttpResponseMessage GetItem(int id) { ... }</p>
<p>[DisableCors]</p>
<p>  [EnableCors("http://localhost:55912", // Origin</p>
<p>              null,                     // Request headers</p>
<p>              "GET",                    // HTTP methods</p>
<p>              "bar",                    // Response headers</p>
<p>              SupportsCredentials=true  // Allow credentials</p>
<p>  )]</p>
<p>  public HttpResponseMessage Get(int id)</p>
<p>If the server allows the request, it sets the Access-Control-Allow-Origin header. The value of this header either matches the Origin header, or is the wildcard value "*", meaning that any origin is allowed. If the response does not include the Access-Control-Allow-Origin header, the AJAX request fails.</p>
<p>Access-Control-Allow-Origin: <u><a href="http://myclient.azurewebsites.net" target="_blank">http://myclient.azurewebsites.net</a></u></p>
<h2>
<strong>Credentials and Authentication </strong><strong>Passing Credentials in Cross-Origin Requests</strong>
</h2>
<p>Generally, authentication with Web APIs can be done either with a cookie or with an Authorization header (there are other ways, but these two are the most common). </p>
<p> It’s possible for a JavaScript client to explicitly send credentials (again, typically via the Authorization header). If this is the case, then none of the aforementioned rules or behaviors related to credentials applies.</p>
<p>Explicitly setting a token value in the Authorization header is a safer approach to authentication because you avoid the possibility of cross-site request forgery (CSRF) attacks. You can see this approach in the new Single-Page Application (SPA) templates in Visual Studio 2013.</p>
<p>$.ajax({</p>
<p>  url: "http://localhost/WebApiCorsServer/Resources/1",</p>
<p>  headers: {</p>
<p>    "Authorization": "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3Mi..."</p>
<p>  }</p>
<p>  // Other settings omitted</p>
<p>});</p>
<p><strong>scenario where the browser is implicitly sending credentials:</strong></p>
<p>In normal browser activity, if one of these has been previously established, then the browser will implicitly pass these values to the server on subsequent requests. With cross-origin AJAX, though, this implicit passing of the values must be explicitly requested in JavaScript (via the withCredentials flag on the XMLHttpRequest) and must be explicitly allowed in the server’s CORS policy (via the Access-Control-Allow-Credentials response header).</p>
<p><strong>The withCredentials flag does two things: If the server issues a cookie, the browser can accept it; if the browser has a cookie, it can send it to the server.</strong></p>
<p>[EnableCors(origins: "http://myclient.azurewebsites.net", headers: "*", methods: "*", SupportsCredentials = true)]</p>
<p>Be very careful about setting <strong>SupportsCredentials</strong> to true, because it means a website at another domain can send a logged-in user's credentials to your Web API on the user's behalf, without the user being aware. The CORS spec also states that setting <em>origins</em> to "*" is invalid if <strong>SupportsCredentials</strong> is true.</p>
<p>$.ajax({</p>
<p>  url: "http://localhost/WebApiCorsServer/Resources/1",</p>
<p>  xhrFields: {</p>
<p>    withCredentials: true</p>
<p>  }</p>
<p>  // Other settings omitted</p>
<p>});</p>
<p>Web API implementation</p>
<p><u><a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/getting-started-with-aspnet-web-api/tutorial-your-first-web-api" target="_blank">https://docs.microsoft.com/en-us/aspnet/web-api/overview/getting-started-with-aspnet-web-api/tutorial-your-first-web-api</a></u> </p>
<p>You can also create a Web API project using the "Web API" template. The Web API template uses ASP.NET MVC to provide API help pages. I'm using the Empty template for this tutorial because I want to show Web API without MVC. In general, you don't need to know ASP.NET MVC to use Web API.</p>
