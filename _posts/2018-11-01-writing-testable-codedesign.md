---
layout: post
title: OOP Design
date: 2018-11-01 09:38
author: tmasabari
comments: true
categories: [Uncategorized]
---
<!-- wp:paragraph -->
<ol>
<li><strong>Mixing object graph construction with application logic</strong>: In a test the thing you want to do is to instantiate a portion (ideally just the class under test) of your application and apply some stimulus to the class and assert that the expected behavior was observed.  In order to instantiate the a class in isolation we have to make sure that the class itself does not instantiate other objects (and those objects do not instantiate more objects and so on). Most developers freely mix the “new” operator with the application logic. In order to have a testable code-base your application should have two kinds of classes. The factories, these are full of the “new” operators and are responsible for building the object graph of your application, but don’t do anything. And the application logic classes which are devoid of the “new” operator and are responsible for doing work. In test we want to test the application logic. And because the application logic is devoid of the “new” operator, we can easily construct an object graph useful for testing where we can strategically replace the real classes for test doubles. (see: <a title="Permanent Link to How to Think About the “new” Operator with Respect to Unit Testing" href="http://misko.hevery.com/2008/07/30/2008/07/08/how-to-think-about-the-new-operator/" rel="bookmark">How to Think About the “new” Operator with Respect to Unit Testing</a>)</li>
<li><strong>Ask for things, Don’t look for things (aka Dependency Injection / Law of Demeter)</strong>: OK, you got rid of your new operators in you application code. But how do I get a hold of the dependencies. Simple: Just ask for all of the collaborators you need in your constructor. If you are a House class then in your constructor you will ask for the Kitchen, LivingRoom, and BedRoom, you will not call the “new” operator on those classes (see 1). Only ask for things you directly need, If you are a CarEngine, don’t ask for FuelTank, only ask for Fuel. Don’t pass in a context/registry/service-locator. So if you are a LoginPage, don’t ask for UserContext, instead ask for the User and the Athenticator. Finally don’t mix the responsibility of work with configuration, If you are an Authenticator class don’t pass in a path of the configuration information which you read inside the constructor to configure yourself, just ask for the configuration object and let some other class worry about reading the object from the disk. In your tests you will not want to write a configuration into a disk just so that your object can read it in again. (see: <a title="Permanent Link to Breaking the Law of Demeter is Like Looking for a Needle in the Haystack" href="http://misko.hevery.com/2008/07/30/2008/07/18/breaking-the-law-of-demeter-is-like-looking-for-a-needle-in-the-haystack/" rel="bookmark">Breaking the Law of Demeter is Like Looking for a Needle in the Haystack</a>)</li>
<li><strong>Doing work in constructor</strong>: A class under tests can have tens of tests. Each test instantiates a slightly different object graph and than applies some stimulus and asserts a response.  As you can see the most common operation you will do in tests is instantiation of object graphs, so make it easy on yourself and make the constructors do no work (other than assigning all of the dependencies into the fields). Any work you do in a constructor, you will have to successfully navigate through on every instantiation (read every test). This may be benign, or it may be something really complex like reading configuration information from the disk. But it is not just a direct test for the class which will have to pay this price, it will also be any related test which tries to instantiate your class indirectly as part of some larger object graph which the test is trying to create.</li>
<li><strong>Global State</strong>: Global state is bad from theoretical, maintainability, and understandability point of view, but is tolerable at run-time as long as you have one instance of your application. However, each test is a small instantiation of your application in contrast to one instance of application in production. The global state persists from one test to the next and creates mass confusion. Tests run in isolation but not together. Worse yet, tests fail together but problems can not be reproduced in isolation. Order of the tests matters. The APIs are not clear about the order of initialization and object instantiation, and so on. I hope that by now most developers agree that global state should be treated like GOTO.</li>
<li><strong>Singletons (global state in sheep’s clothing)</strong>: It amazes me that many developers will agree that global state is bad yet their code is full of singletons. (Singletons which enforce their own singletoness through private constructor and a global instance variable) The core of the issue is that the global instance variables have transitive property! All of the internal objects of the singleton are global as well (and the internals of those objects are global as well… recursively). Singletons are by far the most subtle and insidious thing in unit-testing. I will post more blogs on this topic later as I am sure it will create comments from both sides. (see: <a href="http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/">Singletons are Pathological Lairs</a>)</li>
<li><strong>Static methods: (or living in a procedural world)</strong>: The key to testing is the presence of seams (places where you can divert the normal execution flow). Seams are essentially polymorphism (Polymorphism: at compile-time the method your are calling can not be determined). Seams are needed so that you can isolate the unit of test. If you build an application with nothing but static methods you have procedural application. Procedural code has no seams, at compile-time it is clear which method calls which other method. I don’t know how to test application without seams. How much a static method will hurt from a testing point of view depends on where it is in you application call graph. A leaf method such as Math.abs() is not a problem since the execution call graph ends there. But if you pick a method in a core of your application logic than everything behind the method becomes hard to test, since there is no way to insert test doubles (and there are no seams). Additionally it is really easy for a leaf method to stop being a leaf and than a method which was OK as static no longer is. I don’t know how to unit-test the main method!</li>
<li><strong>Favor composition over inheritance</strong>: At run-time you can not chose a different inheritance, but you can chose a different composition, this is important for tests as we want to test thing in isolation. Many developers use inheritance as code reuse which is wrong. Whether or not inheritance is appropriate depends on whether polymorphism is going on. Inheriting from AuthenticatedServlet will make your sub-class very hard to test since every test will have to mock out the authentication. This will clutter the focus of test, with the things we have to do to successfully navigate the super class. But what if AuthenticatedServlet inherits from DbTransactionServlet? (that gets so much harder)</li>
<li><strong>Favor polymorphism over conditionals</strong>: If you see a switch statement you should think polymorphisms. If you see the same if condition repeated in many places in your class you should again think polymorphism. Polymorphism will break your complex class into several smaller simpler classes which clearly define which pieces of the code are related and execute together. This helps testing since simpler/smaller class is easier to test.</li>
<li><strong>Mixing Service Objects with Value Objects</strong>: There should be two kinds of objects in your application. (1) Value-objects, these tend to have lots of getters / setters and are very easy to construct are never mocked, and probably don’t need an interface. (Example: LinkedList, Map, User, EmailAddress, Email, CreditCard, etc…). (2) Service-objects which do the interesting work, their constructors ask for lots of other objects for colaboration, are good candidates for mocking, tend to have an interface and tend to have multiple implementations (Example: MailServer, CreditCardProcessor, UserAthenticator, AddressValidator). A value-object should never take a service object in its constructor (since than it is not easy to construct). Value-objects are the leafs of your application graph and tend to be created freely with the “new” operator directly in line with your business logic (exception to point 1 since they are leafs). Service-objects are harder to construct and as a result are never constructed with a new operator in-line, (instead use factory / DI-framework) for the object graph construction. Service-objects don’t take value-objects in their constructors since DI-frameworks tend to be unaware about the how to create a value-object. From a testing point of view we like value-objects since we can just create them on the fly and assert on their state. Service-objects are harder to test since their state is not clear and they are all about collaboration and as a result we are forced to use mocking, something which we want to minimize. Mixing the two creates a hybrid which has no advantages of value-objects and all the baggage of service-object.</li>
<li><strong>Mixing of Concerns</strong>: If summing up what the class does includes the word “and”, or class would be challenging for new team members to read and quickly “get it”, or class has fields that are only used in some methods, or class has static methods that only operate on parameters than you have a class which mixes concerns. These classes are hard to tests since there are multiple objects hiding inside of them and as a resulting you are testing all of the objects at once.</li>
</ol>
<p>An OO application is a graph of objects. There are three different kinds of graphs I think of when I design an application</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol>
<li><strong>Collaborator Graph</strong>: This is the graph of objects that would be emitted if you serialized your application. This shows which objects are aware of which others. (through object’s fields)</li>
<li><strong>Construction Graph</strong>: This graph shows which object created which other ones.</li>
<li><strong>Call Graph</strong>: This graph shows which other methods each method calls. A stack-trace would be a single slice through this graph.</li>
</ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>If the new operators are mixed with application logic (see: <a href="http://misko.hevery.com/2008/07/08/how-to-think-about-the-new-operator/">How to Think About the new Operator</a>) then the Constructor Graph and the Collaborator Graph tend to be one and the same. However, in an application which uses Dependency Injection the two graphs are completely independent.</p>
<p>Now, in order to have a testable code base we have to make sure that we don’t mix the object construction with application logic. So all of the above objects should rarely call the new operator (value objects are OK). Instead each of the objects above would declare its collaborators in the constructor.</p>
<p><!-- /wp:paragraph -->

<!-- wp:paragraph --></p>
<p>In our tests it is now easy to instantiate the graph of objects and substitute test-doubles for our collaborators.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lets have a closer look at our CreditCardProcessor example. Suppose this is our collaborator graph which we need to execute a request.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="otNJTgN"><img class="wp-image-1850  aligncenter" src="/wp-content/uploads/2018/11/img_5bda7ddb68727.png" alt="" width="341" height="337" /></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>&nbsp;</p>
<p>Important things to notice:</p>
<ul>
<li>Every object only has references to what it needs directly! No passing around of objects which are not directly needed by the code. <strong>There is no global state at all.</strong> Dependencies are obvious since each object only asks for what it needs.</li>
<li>If an object needs a reference to a new dependency it simply declares it. This change only affects the corresponding factory, and as a result, it is very isolated.</li>
<li>All of the new operators end up in the factories; application logic is devoid of new operators.</li>
<li>You group all of the objects with the same lifetime into a single factory (If the factory gets too big you can break it up into more classes, but you can still think of it as a single factory)</li>
<li>The problem of “how do I ensure that I only have one of something” is nicely sidestepped. You instantiate only a single ApplicationFactory in your main, and as a result, you only instantiate a single instance of all of your singletons.</li>
</ul>
<p>&nbsp;</p>
<h2>References</h2>
<ul>
<li><a href="http://misko.hevery.com/2008/08/21/where-have-all-the-singletons-gone/">http://misko.hevery.com/2008/08/21/where-have-all-the-singletons-gone/</a></li>
<li><a href="http://misko.hevery.com/2008/07/30/top-10-things-which-make-your-code-hard-to-test/">http://misko.hevery.com/2008/07/30/top-10-things-which-make-your-code-hard-to-test/</a></li>
</ul>
<!-- /wp:paragraph -->
